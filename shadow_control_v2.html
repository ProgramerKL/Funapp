<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shadow Mind Control - 3D First Person (V2 - REALISTIC HUMANS)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: #1a1a2e;
        }

        #gameCanvas {
            display: block;
            background: linear-gradient(180deg, #0f3460 0%, #16213e 50%, #1a1a2e 100%);
        }

        .ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 10;
        }

        .hud {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 25px;
            border-radius: 15px;
            color: white;
            font-size: 18px;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(138, 43, 226, 0.3);
            border: 2px solid rgba(138, 43, 226, 0.5);
        }

        .health-bar-container {
            position: absolute;
            bottom: 85px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 30px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 15px;
            padding: 4px;
            border: 2px solid rgba(255, 50, 50, 0.6);
        }

        .health-bar {
            height: 100%;
            background: linear-gradient(90deg, #ff3232 0%, #ff6464 50%, #ff9696 100%);
            border-radius: 12px;
            transition: width 0.3s ease;
            box-shadow: 0 0 15px rgba(255, 50, 50, 0.8);
        }

        .health-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            font-size: 14px;
            white-space: nowrap;
        }

        .energy-bar-container {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            height: 40px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 20px;
            padding: 5px;
            border: 3px solid rgba(138, 43, 226, 0.5);
        }

        .energy-bar {
            height: 100%;
            background: linear-gradient(90deg, #8a2be2 0%, #da70d6 50%, #ee82ee 100%);
            border-radius: 15px;
            transition: width 0.3s ease;
            box-shadow: 0 0 20px rgba(138, 43, 226, 0.8);
        }

        .energy-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            pointer-events: none;
        }

        .controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 15px;
            color: white;
            border: 2px solid rgba(138, 43, 226, 0.5);
            max-width: 300px;
        }

        .controls h3 {
            color: #8a2be2;
            margin-bottom: 10px;
            font-size: 20px;
        }

        .controls p {
            margin: 8px 0;
            font-size: 14px;
            line-height: 1.6;
        }

        .objective {
            position: absolute;
            bottom: 90px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 15px 30px;
            border-radius: 15px;
            color: #da70d6;
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            border: 2px solid #8a2be2;
            min-width: 300px;
        }

        .possession-prompt {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(138, 43, 226, 0.95);
            padding: 30px 50px;
            border-radius: 20px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            display: none;
            pointer-events: none;
            animation: pulse 1s infinite;
            border: 4px solid #da70d6;
        }

        .possession-prompt.show {
            display: block;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 0.8; transform: translate(-50%, -50%) scale(1.05); }
        }

        .game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 50px;
            border-radius: 30px;
            text-align: center;
            color: white;
            display: none;
            pointer-events: auto;
            border: 4px solid #8a2be2;
            box-shadow: 0 0 50px rgba(138, 43, 226, 0.7);
            z-index: 100;
        }

        .game-over.show {
            display: block;
        }

        .game-over h1 {
            font-size: 60px;
            margin-bottom: 20px;
            color: #da70d6;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.8);
        }

        .game-over p {
            font-size: 24px;
            margin: 15px 0;
        }

        .restart-btn {
            margin-top: 30px;
            padding: 20px 50px;
            font-size: 24px;
            background: linear-gradient(135deg, #8a2be2 0%, #da70d6 100%);
            color: white;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 5px 20px rgba(138, 43, 226, 0.4);
        }

        .restart-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 30px rgba(138, 43, 226, 0.6);
        }

        .abilities-bar {
            position: absolute;
            bottom: 90px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            gap: 15px;
        }

        .abilities-bar.show {
            display: flex;
        }

        .ability-button {
            background: rgba(0, 0, 0, 0.85);
            padding: 12px 20px;
            border-radius: 12px;
            color: white;
            font-size: 14px;
            font-weight: bold;
            border: 2px solid rgba(138, 43, 226, 0.6);
            min-width: 120px;
            text-align: center;
            position: relative;
        }

        .ability-button.on-cooldown {
            opacity: 0.5;
            border-color: rgba(138, 43, 226, 0.3);
        }

        .ability-key {
            display: inline-block;
            background: rgba(138, 43, 226, 0.8);
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 12px;
            margin-right: 8px;
        }

        .ability-cooldown {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 4px;
            background: #8a2be2;
            transition: width 0.1s linear;
            border-radius: 0 0 10px 10px;
        }

        .mode-selector {
            position: absolute;
            bottom: 180px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            gap: 10px;
        }

        .mode-selector.show {
            display: flex;
        }

        .mode-btn {
            background: rgba(0, 0, 0, 0.85);
            padding: 10px 18px;
            border-radius: 10px;
            color: white;
            font-size: 14px;
            font-weight: bold;
            border: 2px solid rgba(138, 43, 226, 0.4);
            min-width: 100px;
            text-align: center;
        }

        .mode-btn.active {
            border-color: #8a2be2;
            background: rgba(138, 43, 226, 0.3);
            box-shadow: 0 0 15px rgba(138, 43, 226, 0.6);
        }

        .mode-key {
            display: inline-block;
            background: rgba(138, 43, 226, 0.6);
            padding: 3px 6px;
            border-radius: 4px;
            font-size: 11px;
            margin-right: 6px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div class="ui-overlay">
        <div class="hud">
            <div class="stat-box">
                <span>üë• Possessed: <span id="possessed">0</span> / <span id="totalNPCs">10</span></span>
            </div>
            <div class="stat-box">
                <span>‚è±Ô∏è Time: <span id="time">0</span>s</span>
            </div>
            <div class="stat-box" id="stateDisplay">
                <span>üåë Shadow Form</span>
            </div>
        </div>

        <div class="controls">
            <h3>üéÆ Controls</h3>
            <p><strong>WASD:</strong> Move (First-Person)</p>
            <p><strong>Mouse:</strong> Look Around</p>
            <p><strong>SPACE:</strong> Possess/Release</p>
            <p><strong>K:</strong> Suicide (while possessed)</p>
            <p><strong>Click:</strong> Lock Mouse</p>
            <p><strong>Shadow Energy:</strong> Infinite!</p>
        </div>

        <div class="health-bar-container">
            <div class="health-bar" id="healthBar"></div>
            <div class="health-text">‚ù§Ô∏è SHADOW HEALTH: <span id="healthText">5</span>/5</div>
        </div>

        <div class="energy-bar-container">
            <div class="energy-bar" id="energyBar"></div>
            <div class="energy-text">SHADOW ENERGY: <span id="energyText">100</span>%</div>
        </div>

        <div class="objective" id="objective">
            Possess all villagers in the village!
        </div>

        <div class="possession-prompt" id="possessionPrompt">
            Press SPACE to Possess
        </div>

        <div class="abilities-bar" id="abilitiesBar">
            <div class="ability-button" id="ability1">
                <span class="ability-key">1</span>
                <span class="ability-name">Ability 1</span>
                <div class="ability-cooldown" id="cooldown1" style="width: 0%"></div>
            </div>
            <div class="ability-button" id="ability2">
                <span class="ability-key">2</span>
                <span class="ability-name">Ability 2</span>
                <div class="ability-cooldown" id="cooldown2" style="width: 0%"></div>
            </div>
            <div class="ability-button" id="ability3">
                <span class="ability-key">3</span>
                <span class="ability-name">Ability 3</span>
                <div class="ability-cooldown" id="cooldown3" style="width: 0%"></div>
            </div>
            <div class="ability-button" id="ability4">
                <span class="ability-key">4</span>
                <span class="ability-name">Ability 4</span>
                <div class="ability-cooldown" id="cooldown4" style="width: 0%"></div>
            </div>
            <div class="ability-button" id="stripButton" style="background: rgba(255, 69, 0, 0.3); border-color: rgba(255, 69, 0, 0.5);">
                <span class="ability-key">5</span>
                <span class="ability-name">Strip</span>
            </div>
        </div>

        <div class="mode-selector" id="modeSelector">
            <div class="mode-btn" id="modeStay">
                <span class="mode-key">Q</span>
                <span>STAY</span>
            </div>
            <div class="mode-btn active" id="modeFollow">
                <span class="mode-key">E</span>
                <span>FOLLOW</span>
            </div>
            <div class="mode-btn" id="modeAttack">
                <span class="mode-key">R</span>
                <span>ATTACK</span>
            </div>
        </div>
    </div>

    <div class="game-over" id="gameOver">
        <h1>üåë VICTORY üåë</h1>
        <p>Citizens Possessed: <span id="finalPossessed">0</span></p>
        <p>Time: <span id="finalTime">0</span>s</p>
        <button class="restart-btn" onclick="restartGame()">üîÑ Play Again</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Game state
        let gameRunning = true;
        let shadowEnergy = 100; // Kept for UI display but won't drain
        let possessedCount = 0;
        let gameTime = 0;
        let gameStartTime = Date.now();
        let isPossessing = false;
        let currentHost = null;

        // Level system
        let currentLevel = 'village'; // 'village' or 'airport'
        let airportUnlocked = false;
        let flightAttendantsPossessed = 0;
        let airport = null; // The airport building

        // World size (3D space) - INFINITE EXPANSION
        let worldWidth = 5000;
        let worldDepth = 5000;
        const worldHeight = 300; // Height of world
        const EXPANSION_THRESHOLD = 800; // Expand when player gets within 800 units of edge
        const EXPANSION_SIZE = 2000; // Expand by 2000 units each time

        // Shadow player (first-person 3D)
        const shadow = {
            x: worldWidth / 2,
            y: 100, // Height above ground (eye level)
            z: worldDepth / 2,
            angle: 0, // Looking direction (yaw)
            pitch: 0, // Looking up/down
            speed: 300,
            radius: 20,
            trail: [],
            particles: [],
            health: 5,
            maxHealth: 5,
            invulnerable: false, // Temporary invulnerability after hit
            invulnerabilityTime: 0,
            damageFlash: 0, // Visual damage indicator
            damageText: null, // Damage text to display
            damageTextTime: 0 // Time remaining for damage text
        };

        // Camera/viewport (first-person)
        const camera = {
            fov: Math.PI / 3, // 60 degrees field of view
            renderDistance: 2000,
            mode: 'first-person', // 'first-person' or 'third-person'
            thirdPersonDistance: 300, // Distance behind NPC in third-person
            thirdPersonHeight: 150, // Height above ground in third-person
            transitionProgress: 0, // 0 = first-person, 1 = third-person
            transitionSpeed: 3.0 // How fast to transition between modes
        };

        // NPCs
        const npcs = [];
        const totalNPCs = 30;

        // Game progression tracking
        let atMilitaryBase = false;
        let militaryBaseTeleported = false;
        let militaryBaseFirstPossession = false; // Track if player has possessed anyone at military base

        // Love arrows projectiles
        const loveArrows = [];

        // Bow charging state
        let bowCharging = false;
        let bowChargeTime = 0;
        const maxBowCharge = 1.5; // 1.5 seconds for full charge

        // NPC types with unique abilities
        const npcTypes = [
            {
                color: '#8B4513',
                name: 'Farmer',
                speed: 70,
                attractionRadius: 150, // Farmers attract NPCs within 150 units
                attractionChance: 0.45, // 45% chance to attract nearby NPCs
                attractionReason: 'fresh produce',
                abilities: [
                    { key: '1', name: 'Harvest Call', effect: 'attract_all', cooldown: 5000 },
                    { key: '2', name: 'Till Soil', effect: 'speed_boost', cooldown: 3000 },
                    { key: '3', name: 'Plant Seeds', effect: 'money_rain', cooldown: 8000 },
                    { key: '4', name: 'Barn Dance', effect: 'charm_wave', cooldown: 4000 }
                ]
            },
            {
                color: '#CD853F',
                name: 'Blacksmith',
                speed: 90,
                attractionRadius: 120,
                attractionChance: 0.35,
                attractionReason: 'quality tools',
                abilities: [
                    { key: '1', name: 'Hammer Strike', effect: 'super_speed', cooldown: 4000 },
                    { key: '2', name: 'Forge Fire', effect: 'high_jump', cooldown: 2000 },
                    { key: '3', name: 'Metal Ring', effect: 'energy_burst', cooldown: 6000 },
                    { key: '4', name: 'Anvil Pound', effect: 'flexibility', cooldown: 3000 }
                ]
            },
            {
                color: '#DAA520',
                name: 'Merchant',
                speed: 60,
                attractionRadius: 200, // Merchants attract from far away
                attractionChance: 0.55, // Higher chance (good deals!)
                attractionReason: 'exotic goods',
                abilities: [
                    { key: '1', name: 'Show Wares', effect: 'camera_flash', cooldown: 2000 },
                    { key: '2', name: 'Bargain', effect: 'friendly_wave', cooldown: 3000 },
                    { key: '3', name: 'Trade Route', effect: 'reveal_map', cooldown: 10000 },
                    { key: '4', name: 'Gold Toss', effect: 'pose', cooldown: 4000 }
                ]
            },
            {
                color: '#A0522D',
                name: 'Hunter',
                speed: 120,
                attractionRadius: 80, // Smaller radius (hunters are intimidating)
                attractionChance: 0.30,
                attractionReason: 'hunting stories',
                abilities: [
                    { key: '1', name: 'Track Prey', effect: 'mega_speed', cooldown: 5000 },
                    { key: '2', name: 'Whistle', effect: 'alert_sound', cooldown: 1000 },
                    { key: '3', name: 'Set Trap', effect: 'spin_move', cooldown: 4000 },
                    { key: '4', name: 'Aim Bow', effect: 'show_off', cooldown: 3000 }
                ]
            },
            {
                color: '#556B2F',
                name: 'Herbalist',
                speed: 65,
                attractionRadius: 180,
                attractionChance: 0.50, // People seek healing
                attractionReason: 'healing herbs',
                abilities: [
                    { key: '1', name: 'Herb Brew', effect: 'attract_all', cooldown: 5000 },
                    { key: '2', name: 'Gather Plants', effect: 'speed_boost', cooldown: 3000 },
                    { key: '3', name: 'Healing Aura', effect: 'energy_burst', cooldown: 8000 },
                    { key: '4', name: 'Nature Call', effect: 'charm_wave', cooldown: 4000 }
                ]
            },
            {
                color: '#8B7355',
                name: 'Woodcutter',
                speed: 85,
                attractionRadius: 100,
                attractionChance: 0.40,
                attractionReason: 'firewood supply',
                abilities: [
                    { key: '1', name: 'Axe Swing', effect: 'super_speed', cooldown: 4000 },
                    { key: '2', name: 'Log Roll', effect: 'high_jump', cooldown: 2000 },
                    { key: '3', name: 'Timber!', effect: 'energy_burst', cooldown: 6000 },
                    { key: '4', name: 'Chop Rally', effect: 'flexibility', cooldown: 3000 }
                ]
            },
            {
                color: '#BC8F8F',
                name: 'Baker',
                speed: 55,
                attractionRadius: 220, // Smell of bread travels far!
                attractionChance: 0.60, // Highest attraction (everyone loves bread)
                attractionReason: 'delicious bread',
                abilities: [
                    { key: '1', name: 'Fresh Bread', effect: 'attract_all', cooldown: 5000 },
                    { key: '2', name: 'Knead Dough', effect: 'speed_boost', cooldown: 3000 },
                    { key: '3', name: 'Oven Warmth', effect: 'money_rain', cooldown: 8000 },
                    { key: '4', name: 'Sweet Scent', effect: 'charm_wave', cooldown: 4000 }
                ]
            },
            {
                color: '#4682B4',
                name: 'Fisherman',
                speed: 75,
                attractionRadius: 140,
                attractionChance: 0.43,
                attractionReason: 'fresh fish',
                abilities: [
                    { key: '1', name: 'Cast Net', effect: 'mega_speed', cooldown: 5000 },
                    { key: '2', name: 'Fishing Song', effect: 'alert_sound', cooldown: 1000 },
                    { key: '3', name: 'Big Catch', effect: 'spin_move', cooldown: 4000 },
                    { key: '4', name: 'Water Splash', effect: 'show_off', cooldown: 3000 }
                ]
            },
            {
                color: '#9B59B6',
                name: 'Bard',
                speed: 80,
                attractionRadius: 160,
                attractionChance: 0.48,
                attractionReason: 'beautiful music',
                abilities: [
                    { key: '1', name: 'Love Song', effect: 'attract_opposite_gender', cooldown: 6000 },
                    { key: '2', name: 'Dance', effect: 'speed_boost', cooldown: 3000 },
                    { key: '3', name: 'Serenade', effect: 'charm_wave', cooldown: 4000 },
                    { key: '4', name: 'Epic Tale', effect: 'show_off', cooldown: 5000 }
                ]
            },
            {
                color: '#E74C3C',
                name: 'Town Crier',
                speed: 70,
                attractionRadius: 130,
                attractionChance: 0.38,
                attractionReason: 'important news',
                abilities: [
                    { key: '1', name: 'Loud Shout', effect: 'push_all_away', cooldown: 7000 },
                    { key: '2', name: 'Ring Bell', effect: 'alert_sound', cooldown: 1000 },
                    { key: '3', name: 'Proclamation', effect: 'attract_all', cooldown: 5000 },
                    { key: '4', name: 'Wave Scroll', effect: 'friendly_wave', cooldown: 2000 }
                ]
            },
            {
                color: '#FF69B4',
                name: 'Cupid',
                speed: 90,
                attractionRadius: 200,
                attractionChance: 0.65,
                attractionReason: 'love arrows',
                abilities: [
                    { key: '1', name: 'Love Arrow Shot', effect: 'shoot_love_arrow', cooldown: 2000 },
                    { key: '2', name: 'Heart Burst', effect: 'mass_love_aura', cooldown: 8000 },
                    { key: '3', name: 'Cupid Dash', effect: 'mega_speed', cooldown: 4000 },
                    { key: '4', name: 'Romance Cloud', effect: 'charm_wave', cooldown: 6000 }
                ]
            },
            {
                color: '#FFC0CB',
                name: 'Matchmaker',
                speed: 75,
                attractionRadius: 170,
                attractionChance: 0.58,
                attractionReason: 'perfect matches',
                abilities: [
                    { key: '1', name: 'Love Potion', effect: 'attract_opposite_gender', cooldown: 6000 },
                    { key: '2', name: 'Matchmaking', effect: 'pair_npcs', cooldown: 10000 },
                    { key: '3', name: 'Romance Dance', effect: 'speed_boost', cooldown: 3000 },
                    { key: '4', name: 'Heart Eyes', effect: 'charm_wave', cooldown: 4000 }
                ]
            },
            {
                color: '#FF1493',
                name: 'Love Priest',
                speed: 65,
                attractionRadius: 190,
                attractionChance: 0.55,
                attractionReason: 'wedding blessings',
                abilities: [
                    { key: '1', name: 'Mass Wedding', effect: 'mass_love_aura', cooldown: 9000 },
                    { key: '2', name: 'Love Blessing', effect: 'attract_opposite_gender', cooldown: 5000 },
                    { key: '3', name: 'Holy Matrimony', effect: 'energy_burst', cooldown: 7000 },
                    { key: '4', name: 'Ring Exchange', effect: 'pose', cooldown: 3000 }
                ]
            }
        ];

        // Active effects tracking
        const activeEffects = [];

        // Police squad
        const policeSquad = [];
        let policeSpawned = false;
        const POLICE_SPAWN_THRESHOLD = 10; // Spawn police after 10 possessions

        // Buildings
        const buildings = [];

        // Keyboard controls
        const keys = {
            w: false,
            a: false,
            s: false,
            d: false,
            ' ': false,
            '1': false,
            '2': false,
            '3': false,
            '4': false,
            '5': false, // Strip command
            'q': false, // Mode: Stay
            'e': false, // Mode: Follow
            'r': false, // Mode: Attack
            'k': false  // Suicide
        };

        // Mouse controls for looking
        let mouseX = 0;
        let mouseY = 0;
        let isPointerLocked = false;

        canvas.addEventListener('click', () => {
            canvas.requestPointerLock();
        });

        document.addEventListener('pointerlockchange', () => {
            isPointerLocked = document.pointerLockElement === canvas;
        });

        document.addEventListener('mousemove', (e) => {
            if (isPointerLocked) {
                shadow.angle -= e.movementX * 0.002; // Mouse sensitivity
                shadow.pitch -= e.movementY * 0.002;
                // Clamp pitch to prevent over-rotation
                shadow.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, shadow.pitch));
            }
        });

        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (keys.hasOwnProperty(key)) {
                keys[key] = true;
                e.preventDefault();
            }
        });

        window.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (keys.hasOwnProperty(key)) {
                keys[key] = false;
                e.preventDefault();
            }
        });

        // Mode button click listeners
        document.getElementById('modeStay').addEventListener('click', () => {
            if (isPossessing && currentHost) {
                currentHost.mode = 'stay';
                console.log('Mode set to: STAY (clicked)');
                updateModeUI();
            }
        });

        document.getElementById('modeFollow').addEventListener('click', () => {
            if (isPossessing && currentHost) {
                currentHost.mode = 'follow';
                console.log('Mode set to: FOLLOW (clicked)');
                updateModeUI();
            }
        });

        document.getElementById('modeAttack').addEventListener('click', () => {
            if (isPossessing && currentHost) {
                if (policeSpawned) {
                    currentHost.mode = 'attack';
                    console.log('Mode set to: ATTACK (clicked)');
                } else {
                    currentHost.mode = 'follow';
                    console.log('No police spawned yet - Mode set to: FOLLOW (clicked)');
                }
                updateModeUI();
            }
        });

        // Strip button click listener
        document.getElementById('stripButton').addEventListener('click', () => {
            if (isPossessing && currentHost) {
                if (currentHost.clothingLevel > 0) {
                    const wasFullyClothed = currentHost.clothingLevel === 3;
                    currentHost.clothingLevel--;
                    const clothingStates = ['completely naked', 'in underwear only', 'partially clothed', 'fully clothed'];
                    console.log(`${currentHost.name} is now ${clothingStates[currentHost.clothingLevel]} (clicked)`);

                    // Trigger strip animation
                    currentHost.stripAnim = 1.0;
                    currentHost.leftArmAngle = Math.PI * 0.5; // 90 degrees up
                    currentHost.rightArmAngle = Math.PI * 0.5; // 90 degrees up

                    // When first stripped (from fully clothed to partial), trigger charm/disgust mechanic
                    if (wasFullyClothed && currentHost.clothingLevel < 3) {
                        // 50% chance to charm or disgust
                        const charmRoll = Math.random();
                        currentHost.stripReaction = charmRoll < 0.5 ? 'charm' : 'disgust';

                        if (currentHost.stripReaction === 'charm') {
                            console.log(`${currentHost.name}'s strip is CHARMING! NPCs are more attracted!`);
                            currentHost.charmBonus = 1.5; // 150% attraction
                        } else {
                            console.log(`${currentHost.name}'s strip is DISGUSTING! NPCs are less attracted!`);
                            currentHost.charmBonus = 0.7; // 70% attraction
                        }

                        // Apply the effect to all NPCs in range
                        npcs.forEach(otherNpc => {
                            if (otherNpc !== currentHost && !otherNpc.isPolice && otherNpc.gender !== currentHost.gender) {
                                const dx = otherNpc.x - currentHost.x;
                                const dz = otherNpc.z - currentHost.z;
                                const dist = Math.sqrt(dx * dx + dz * dz);

                                // Apply to NPCs within 1000 units
                                if (dist < 1000) {
                                    // Re-roll their attraction with the new probability
                                    if (currentHost.stripReaction === 'charm') {
                                        // Higher chance of attraction (guaranteed if within range)
                                        if (!otherNpc.attractionMap) otherNpc.attractionMap = new Map();
                                        otherNpc.attractionMap.set(currentHost.id, true);
                                    } else {
                                        // Lower chance - re-roll with 70% probability
                                        if (!otherNpc.attractionMap) otherNpc.attractionMap = new Map();
                                        otherNpc.attractionMap.set(currentHost.id, Math.random() < 0.7);
                                    }
                                }
                            }
                        });
                    }

                    updateAbilitiesUI();
                } else {
                    console.log(`${currentHost.name} is already naked!`);
                }
            }
        });

        // Initialize game
        // Check if a position collides with any building
        function checkBuildingCollision(x, z, radius = 30) {
            for (let building of buildings) {
                // Check AABB collision (Axis-Aligned Bounding Box)
                const closestX = Math.max(building.x - building.width / 2, Math.min(x, building.x + building.width / 2));
                const closestZ = Math.max(building.z - building.depth / 2, Math.min(z, building.z + building.depth / 2));

                const distX = x - closestX;
                const distZ = z - closestZ;
                const distSquared = distX * distX + distZ * distZ;

                if (distSquared < radius * radius) {
                    return building; // Collision detected
                }
            }
            return null; // No collision
        }

        // Check if line of sight between two points is blocked by any building
        function checkLineOfSight(x1, z1, x2, z2) {
            // Ray from (x1, z1) to (x2, z2)
            const dx = x2 - x1;
            const dz = z2 - z1;
            const distance = Math.sqrt(dx * dx + dz * dz);

            if (distance === 0) return true; // Same position

            const dirX = dx / distance;
            const dirZ = dz / distance;

            // Check each building to see if the ray intersects it
            for (let building of buildings) {
                // Building bounds
                const minX = building.x - building.width / 2;
                const maxX = building.x + building.width / 2;
                const minZ = building.z - building.depth / 2;
                const maxZ = building.z + building.depth / 2;

                // Ray-AABB intersection test (2D, assuming infinite height)
                // Calculate intersection distances for each axis
                const tMinX = (minX - x1) / dirX;
                const tMaxX = (maxX - x1) / dirX;
                const tMinZ = (minZ - z1) / dirZ;
                const tMaxZ = (maxZ - z1) / dirZ;

                // Swap if needed
                const tNearX = Math.min(tMinX, tMaxX);
                const tFarX = Math.max(tMinX, tMaxX);
                const tNearZ = Math.min(tMinZ, tMaxZ);
                const tFarZ = Math.max(tMinZ, tMaxZ);

                // Check if ray intersects the AABB
                const tNear = Math.max(tNearX, tNearZ);
                const tFar = Math.min(tFarX, tFarZ);

                // Ray intersects if tNear <= tFar and intersection is within the ray segment
                if (tNear <= tFar && tNear >= 0 && tNear <= distance) {
                    return false; // Line of sight is blocked
                }
            }

            return true; // Line of sight is clear
        }

        function init() {
            // Create buildings spread across 3D world (positioned in front of spawn)
            for (let i = 0; i < 40; i++) {
                const width = 80 + Math.random() * 120;
                const depth = 80 + Math.random() * 120;
                const height = 150 + Math.random() * 300;

                // Spawn buildings in a circular area around spawn point
                const angle = (Math.PI * 2 * i) / 40;
                const distance = 300 + Math.random() * 1500;
                const x = worldWidth / 2 + Math.cos(angle) * distance;
                const z = worldDepth / 2 + Math.sin(angle) * distance;

                buildings.push({
                    x: x,
                    z: z,
                    width: width,
                    depth: depth,
                    height: height,
                    color: '#' + Math.floor(Math.random() * 0x333333 + 0x333333).toString(16),
                    windows: []
                });
            }

            // Create NPCs with unique characteristics (positioned around player)
            // More diverse and realistic skin tones
            const skinTones = ['#FDBCB4', '#F1C27D', '#E0AC69', '#D4A574', '#C68642', '#A67B5B', '#8D5524', '#6B4423'];
            const bodyTypes = ['slim', 'average', 'athletic', 'heavy'];
            const genders = ['male', 'female'];
            const hairStyles = ['short', 'long', 'bald', 'ponytail'];
            // More natural hair color variations
            const hairColors = ['#2C3E50', '#8B4513', '#654321', '#A0522D', '#FFD700', '#000000', '#4A4A4A', '#8B7355'];

            // First NPC: DIRECTLY IN FRONT at eye level for testing
            const testType = npcTypes[0]; // Use Business Person type
            const testNPC = {
                x: worldWidth / 2,
                y: 0,
                z: worldDepth / 2 + 500, // 500 units in FRONT (angle 0 looks in +Z direction with fixed rotation)
                vx: 0,
                vz: 0,
                radius: 30,
                height: 180,
                color: '#FF0000', // Bright red
                name: "TEST NPC - IN FRONT",
                speed: 80,
                possessed: false,
                targetX: null,
                targetZ: null,
                skinTone: '#FDBCB4',
                bodyType: 'average',
                gender: 'male',
                hairStyle: 'short',
                hairColor: '#2C3E50',
                personHeight: 30,
                id: -1,
                // Possession animation state
                possessionAnim: 0,
                backArch: 0,
                // Strip animation state
                stripAnim: 0,
                leftArmAngle: 0,
                rightArmAngle: 0,
                // Abilities
                type: testType,
                abilities: testType.abilities,
                abilityCooldowns: [0, 0, 0, 0],
                activeEffects: [],
                // Possession tracking
                everPossessed: false,
                currentlyControlled: false
            };
            npcs.push(testNPC);

            // Filter out military-only NPCs (Cupid, Matchmaker, Love Priest) - Keep Bard in all levels
            const villageNPCTypes = npcTypes.filter(type =>
                type.name !== 'Cupid' && type.name !== 'Matchmaker' &&
                type.name !== 'Love Priest'
            );

            for (let i = 0; i < totalNPCs; i++) {
                const type = villageNPCTypes[Math.floor(Math.random() * villageNPCTypes.length)];

                // Spawn NPCs in visible range - much closer!
                // Keep trying to find a valid spawn position (not inside buildings)
                let x, z;
                let attempts = 0;
                const maxAttempts = 50; // Prevent infinite loop

                do {
                    const angle = (Math.PI * 2 * i) / totalNPCs + Math.random() * 0.2; // Add some randomness
                    const distance = 200 + Math.random() * 600; // Closer: 200-800 units
                    x = worldWidth / 2 + Math.cos(angle) * distance;
                    z = worldDepth / 2 + Math.sin(angle) * distance;
                    attempts++;
                } while (checkBuildingCollision(x, z, 30) && attempts < maxAttempts);

                // If we couldn't find a valid position after max attempts, use the last position anyway
                // (better than no NPC at all)

                // 70% female, 30% male
                const gender = Math.random() < 0.7 ? 'female' : 'male';

                // Assign hair style based on gender
                let hairStyle;
                if (gender === 'male') {
                    // Males only get short hair or bald
                    hairStyle = Math.random() < 0.8 ? 'short' : 'bald';
                } else {
                    // Females can have any style
                    hairStyle = hairStyles[Math.floor(Math.random() * hairStyles.length)];
                }

                const npc = {
                    x: x,
                    y: 0, // Ground level in 3D
                    z: z,
                    vx: 0,
                    vz: 0,
                    radius: 30,
                    height: 170 + Math.random() * 30, // More realistic height variation (5'7" to 6'7")
                    color: type.color,
                    name: type.name,
                    speed: type.speed,
                    possessed: false,
                    targetX: null,
                    targetZ: null,
                    // Unique appearance
                    skinTone: skinTones[Math.floor(Math.random() * skinTones.length)],
                    bodyType: bodyTypes[Math.floor(Math.random() * bodyTypes.length)],
                    gender: gender,
                    hairStyle: hairStyle,
                    hairColor: hairColors[Math.floor(Math.random() * hairColors.length)],
                    personHeight: 20 + Math.random() * 15, // More height variation (20-35 instead of 25-35)
                    id: i,
                    // Possession animation state
                    possessionAnim: 0,
                    backArch: 0,
                    // Strip animation state
                    stripAnim: 0,
                    leftArmAngle: 0,
                    rightArmAngle: 0,
                    // Clothing state (0 = naked, 1 = underwear, 2 = partial clothes, 3 = fully clothed)
                    clothingLevel: 3,
                    // Abilities
                    type: type,
                    abilities: type.abilities,
                    abilityCooldowns: [0, 0, 0, 0], // Cooldown timers for each ability
                    activeEffects: [], // Active effects on this NPC
                    // Possession tracking
                    everPossessed: false,
                    currentlyControlled: false,
                    // Combat stats
                    health: 100,
                    maxHealth: 100,
                    isPolice: false,
                    attackCooldown: 0,
                    attackDamage: 10,
                    // AI Mode
                    mode: 'follow' // 'stay', 'follow', or 'attack'
                };
                npcs.push(npc);
            }

            // Add 2 Flight Attendants near the airport location
            const attendantType = {
                color: '#0066FF', // Blue uniform
                name: 'Flight Attendant',
                speed: 75,
                abilities: [
                    { key: '1', name: 'Boarding Call', effect: 'attract_all', cooldown: 5000 },
                    { key: '2', name: 'Safety Demo', effect: 'charm_wave', cooldown: 4000 },
                    { key: '3', name: 'Service Smile', effect: 'friendly_wave', cooldown: 3000 },
                    { key: '4', name: 'Jet Lag Cure', effect: 'energy_burst', cooldown: 6000 }
                ]
            };

            for (let i = 0; i < 2; i++) {
                // Keep trying to find a valid spawn position (not inside buildings)
                let x, z;
                let attempts = 0;
                const maxAttempts = 50;

                do {
                    // Spawn farther from airport entrance (400-600 units away instead of 100)
                    x = worldWidth / 2 + 300 + i * 200 + Math.random() * 100; // More spread out
                    z = worldDepth / 2 - 400 + Math.random() * 100; // Much farther from entrance
                    attempts++;
                } while (checkBuildingCollision(x, z, 30) && attempts < maxAttempts);

                const attendant = {
                    x: x,
                    y: 0,
                    z: z,
                    vx: 0,
                    vz: 0,
                    radius: 30,
                    height: 170 + Math.random() * 20,
                    color: '#0066FF', // Blue uniform
                    name: 'Flight Attendant',
                    speed: 75,
                    possessed: false,
                    targetX: null,
                    targetZ: null,
                    skinTone: skinTones[Math.floor(Math.random() * skinTones.length)],
                    bodyType: 'slim',
                    gender: 'female', // Always female
                    hairStyle: Math.random() < 0.5 ? 'long' : 'ponytail',
                    hairColor: hairColors[Math.floor(Math.random() * hairColors.length)],
                    personHeight: 25 + Math.random() * 10,
                    id: 500 + i, // Special ID range for attendants
                    possessionAnim: 0,
                    backArch: 0,
                    stripAnim: 0,
                    leftArmAngle: 0,
                    rightArmAngle: 0,
                    clothingLevel: 3,
                    type: attendantType,
                    abilities: attendantType.abilities,
                    abilityCooldowns: [0, 0, 0, 0],
                    activeEffects: [],
                    everPossessed: false,
                    currentlyControlled: false,
                    health: 100,
                    maxHealth: 100,
                    isPolice: false,
                    attackCooldown: 0,
                    attackDamage: 10,
                    mode: 'follow',
                    isFlightAttendant: true // Special flag
                };
                npcs.push(attendant);
            }

            // Create the Airport building
            airport = {
                x: worldWidth / 2 + 700,
                y: 0,
                z: worldDepth / 2 - 900,
                width: 300,
                height: 200,
                depth: 400,
                color: '#B0C4DE', // Light steel blue
                isAirport: true,
                locked: true
            };
            buildings.push(airport);

            document.getElementById('totalNPCs').textContent = totalNPCs + 2; // Include attendants

            console.log('Game initialized:', npcs.length, 'NPCs (including 2 flight attendants),', buildings.length, 'buildings');
            console.log('Player position:', shadow.x, shadow.y, shadow.z);
        }

        // Check and expand world if needed
        function checkWorldExpansion() {
            let expanded = false;

            // Check if shadow is near edges
            if (shadow.x < EXPANSION_THRESHOLD) {
                // Expand left - shift everything right
                const shift = EXPANSION_SIZE;
                shadow.x += shift;
                npcs.forEach(npc => npc.x += shift);
                buildings.forEach(b => b.x += shift);
                worldWidth += shift;
                expanded = true;
            }
            if (shadow.x > worldWidth - EXPANSION_THRESHOLD) {
                // Expand right
                worldWidth += EXPANSION_SIZE;
                expanded = true;
                // Spawn new buildings in expanded area
                spawnBuildingsInArea(worldWidth - EXPANSION_SIZE, 0, EXPANSION_SIZE, worldDepth);
            }
            if (shadow.z < EXPANSION_THRESHOLD) {
                // Expand forward - shift everything back
                const shift = EXPANSION_SIZE;
                shadow.z += shift;
                npcs.forEach(npc => npc.z += shift);
                buildings.forEach(b => b.z += shift);
                worldDepth += shift;
                expanded = true;
            }
            if (shadow.z > worldDepth - EXPANSION_THRESHOLD) {
                // Expand backward
                worldDepth += EXPANSION_SIZE;
                expanded = true;
                // Spawn new buildings in expanded area
                spawnBuildingsInArea(0, worldDepth - EXPANSION_SIZE, worldWidth, EXPANSION_SIZE);
            }

            if (expanded) {
                console.log('World expanded! New size:', worldWidth, 'x', worldDepth);
            }
        }

        // Spawn buildings in a specific area
        function spawnBuildingsInArea(x, z, width, depth) {
            const numBuildings = Math.floor((width * depth) / 30000); // More huts (denser)

            // Village hut color palette - natural materials
            const hutColors = [
                '#8B4513', // Saddle brown (wood)
                '#A0522D', // Sienna (clay)
                '#D2691E', // Chocolate (thatch)
                '#CD853F', // Peru (light wood)
                '#8B7355', // Burlywood dark (straw)
                '#A0826D', // Light brown (mud)
                '#996633', // Brown (wood planks)
                '#B8860B'  // Dark goldenrod (dried grass)
            ];

            // Hut types
            const hutTypes = ['small', 'medium', 'large'];

            for (let i = 0; i < numBuildings; i++) {
                const bx = x + Math.random() * width;
                const bz = z + Math.random() * depth;

                const hutType = hutTypes[Math.floor(Math.random() * hutTypes.length)];
                let hutWidth, hutHeight, hutDepth;

                // Village hut dimensions - much smaller and lower
                if (hutType === 'small') {
                    hutWidth = 40 + Math.random() * 30; // 40-70 units
                    hutDepth = 40 + Math.random() * 30;
                    hutHeight = 60 + Math.random() * 40; // 60-100 units (low huts)
                } else if (hutType === 'medium') {
                    hutWidth = 60 + Math.random() * 40; // 60-100 units
                    hutDepth = 60 + Math.random() * 40;
                    hutHeight = 80 + Math.random() * 50; // 80-130 units
                } else { // large
                    hutWidth = 90 + Math.random() * 50; // 90-140 units
                    hutDepth = 90 + Math.random() * 50;
                    hutHeight = 100 + Math.random() * 60; // 100-160 units
                }

                const building = {
                    x: bx,
                    y: 0,
                    z: bz,
                    width: hutWidth,
                    height: hutHeight,
                    depth: hutDepth,
                    color: hutColors[Math.floor(Math.random() * hutColors.length)],
                    isHut: true // Mark as hut for different rendering
                };
                buildings.push(building);
            }
        }

        // Update game
        function update(deltaTime) {
            if (!gameRunning) return;

            // Update game time
            gameTime = Math.floor((Date.now() - gameStartTime) / 1000);
            document.getElementById('time').textContent = gameTime;

            // Update shadow invulnerability
            if (shadow.invulnerable) {
                shadow.invulnerabilityTime -= deltaTime;
                if (shadow.invulnerabilityTime <= 0) {
                    shadow.invulnerable = false;
                }
            }

            // Update damage flash effect
            if (shadow.damageFlash > 0) {
                shadow.damageFlash -= deltaTime * 2.0; // Fade out over 0.5 seconds
                shadow.damageFlash = Math.max(0, shadow.damageFlash);
            }

            // Update damage text timer
            if (shadow.damageTextTime > 0) {
                shadow.damageTextTime -= deltaTime;
                if (shadow.damageTextTime <= 0) {
                    shadow.damageText = null;
                }
            }

            // Check for world expansion
            checkWorldExpansion();

            // Check if shadow (or possessed NPC) entered the airport
            if (airportUnlocked && airport && currentLevel === 'village') {
                // Use current host position if possessing, otherwise use shadow position
                const checkX = isPossessing && currentHost ? currentHost.x : shadow.x;
                const checkZ = isPossessing && currentHost ? currentHost.z : shadow.z;

                const inAirport = checkX >= airport.x && checkX <= airport.x + airport.width &&
                                 checkZ >= airport.z && checkZ <= airport.z + airport.depth;
                if (inAirport) {
                    transitionToAirport();
                }
            }

            // Check if 15 airport staff are possessed -> teleport to military base
            // Only check when at the airport level
            if (!militaryBaseTeleported && !atMilitaryBase && currentLevel === 'airport') {
                // Count all possessed NPCs at airport (including all airport staff types)
                const possessedAirportNPCs = npcs.filter(npc => npc.everPossessed).length;

                if (possessedAirportNPCs >= 15) {
                    console.log(`üéñÔ∏è ${possessedAirportNPCs}/15 airport staff possessed! Teleporting to MILITARY BASE! üéñÔ∏è`);
                    militaryBaseTeleported = true;
                    setTimeout(() => {
                        transitionToMilitaryBase();
                    }, 2000); // 2 second delay for dramatic effect
                }
            }

            // Update active effects
            updateEffects(deltaTime);

            // Update love arrows
            updateLoveArrows(deltaTime);

            // Update camera mode transitions
            if (camera.mode === 'third-person') {
                // Transition to third-person view
                camera.transitionProgress = Math.min(1, camera.transitionProgress + deltaTime * camera.transitionSpeed);

                // Check if animation is complete and transition back to first-person (for female back arch)
                if (isPossessing && currentHost && currentHost.gender === 'female') {
                    if (currentHost.backArch <= 0) {
                        // Female back arch animation complete, transition back to first-person
                        camera.mode = 'first-person';
                    }
                }
                // For males, stay in third-person view while possessing
            } else if (camera.mode === 'first-person') {
                // Transition back to first-person view
                camera.transitionProgress = Math.max(0, camera.transitionProgress - deltaTime * camera.transitionSpeed * 2); // 2x faster transition back
            }

            if (isPossessing && currentHost) {
                // Control host in 3D space - even during animation
                // Use faster speed during possession for better control
                const speed = currentHost.speed * 1.5; // 1.5x speed for responsive control

                // Store old position for collision checking
                const oldX = currentHost.x;
                const oldZ = currentHost.z;

                let moved = false;

                // Forward/backward (move along looking direction)
                if (keys.w) {
                    currentHost.x -= Math.sin(shadow.angle) * speed * deltaTime;
                    currentHost.z += Math.cos(shadow.angle) * speed * deltaTime;
                    moved = true;
                }
                if (keys.s) {
                    currentHost.x += Math.sin(shadow.angle) * speed * deltaTime;
                    currentHost.z -= Math.cos(shadow.angle) * speed * deltaTime;
                    moved = true;
                }

                // Strafe left/right (perpendicular to looking direction)
                if (keys.a) {
                    currentHost.x -= Math.cos(shadow.angle) * speed * deltaTime;
                    currentHost.z -= Math.sin(shadow.angle) * speed * deltaTime;
                    moved = true;
                }
                if (keys.d) {
                    currentHost.x += Math.cos(shadow.angle) * speed * deltaTime;
                    currentHost.z += Math.sin(shadow.angle) * speed * deltaTime;
                    moved = true;
                }

                // Check collision with buildings - NPCs can't phase through
                if (checkBuildingCollision(currentHost.x, currentHost.z, currentHost.radius)) {
                    // Revert to old position
                    currentHost.x = oldX;
                    currentHost.z = oldZ;
                }

                // No world bounds - infinite expansion!

                // Shadow follows host
                shadow.x = currentHost.x;
                shadow.z = currentHost.z;

                // Energy stays full (no drain)
                shadowEnergy = 100;

                // Check for mode change (Q = Stay, E = Follow, R = Attack)
                if (keys['q']) {
                    currentHost.mode = 'stay';
                    keys['q'] = false;
                    console.log('Mode set to: STAY');
                    updateModeUI();
                }
                if (keys['e']) {
                    currentHost.mode = 'follow';
                    keys['e'] = false;
                    console.log('Mode set to: FOLLOW');
                    updateModeUI();
                }
                if (keys['r']) {
                    // Only allow attack mode if police exist
                    if (policeSpawned) {
                        currentHost.mode = 'attack';
                        console.log('Mode set to: ATTACK');
                    } else {
                        currentHost.mode = 'follow';
                        console.log('No police spawned yet - Mode set to: FOLLOW');
                    }
                    keys['r'] = false;
                    updateModeUI();
                }

                // Check for release
                if (keys[' ']) {
                    // Just release immediately - no complex animation
                    releasePossession();
                    keys[' '] = false;
                }

                // Check for ability usage (1, 2, 3, 4 keys)
                for (let i = 0; i < 4; i++) {
                    const key = (i + 1).toString();

                    // Special handling for Cupid's bow (ability index 0, key '1')
                    if (i === 0 && currentHost.name === 'Cupid') {
                        if (keys[key] && currentHost.abilityCooldowns[i] <= 0) {
                            // Start charging the bow
                            if (!bowCharging) {
                                bowCharging = true;
                                bowChargeTime = 0;
                            }
                        } else if (!keys[key] && bowCharging) {
                            // Release the arrow when key is released
                            useAbility(currentHost, i);
                            bowCharging = false;
                            bowChargeTime = 0;
                        }
                    } else {
                        // Normal ability usage for other abilities
                        if (keys[key] && currentHost.abilityCooldowns[i] <= 0) {
                            useAbility(currentHost, i);
                            keys[key] = false;
                        }
                    }
                }

                // Update bow charge time for Cupid
                if (bowCharging && currentHost.name === 'Cupid') {
                    bowChargeTime = Math.min(bowChargeTime + deltaTime, maxBowCharge);
                }

                // Check for strip command (5 key)
                if (keys['5']) {
                    if (currentHost.clothingLevel > 0) {
                        const wasFullyClothed = currentHost.clothingLevel === 3;
                        currentHost.clothingLevel--;
                        const clothingStates = ['completely naked', 'in underwear only', 'partially clothed', 'fully clothed'];
                        console.log(`${currentHost.name} is now ${clothingStates[currentHost.clothingLevel]}`);

                        // Trigger strip animation
                        currentHost.stripAnim = 1.0;
                        currentHost.leftArmAngle = Math.PI * 0.5; // 90 degrees up
                        currentHost.rightArmAngle = Math.PI * 0.5; // 90 degrees up

                        // When first stripped (from fully clothed to partial), trigger charm/disgust mechanic
                        if (wasFullyClothed && currentHost.clothingLevel < 3) {
                            // 50% chance to charm or disgust
                            const charmRoll = Math.random();
                            currentHost.stripReaction = charmRoll < 0.5 ? 'charm' : 'disgust';

                            if (currentHost.stripReaction === 'charm') {
                                console.log(`${currentHost.name}'s strip is CHARMING! NPCs are more attracted!`);
                                // Increase attraction - set special flag
                                currentHost.charmBonus = 1.5; // 150% attraction
                            } else {
                                console.log(`${currentHost.name}'s strip is DISGUSTING! NPCs are less attracted!`);
                                // Decrease attraction to 70%
                                currentHost.charmBonus = 0.7; // 70% attraction
                            }

                            // Apply the effect to all NPCs in range
                            npcs.forEach(otherNpc => {
                                if (otherNpc !== currentHost && !otherNpc.isPolice && otherNpc.gender !== currentHost.gender) {
                                    const dx = otherNpc.x - currentHost.x;
                                    const dz = otherNpc.z - currentHost.z;
                                    const dist = Math.sqrt(dx * dx + dz * dz);

                                    // Apply to NPCs within 1000 units
                                    if (dist < 1000) {
                                        // Re-roll their attraction with the new probability
                                        if (currentHost.stripReaction === 'charm') {
                                            // Higher chance of attraction (guaranteed if within range)
                                            if (!otherNpc.attractionMap) otherNpc.attractionMap = new Map();
                                            otherNpc.attractionMap.set(currentHost.id, true);
                                        } else {
                                            // Lower chance - re-roll with 70% probability
                                            if (!otherNpc.attractionMap) otherNpc.attractionMap = new Map();
                                            otherNpc.attractionMap.set(currentHost.id, Math.random() < 0.7);
                                        }
                                    }
                                }
                            });
                        }

                        updateAbilitiesUI(); // Update the UI to show new clothing level
                    } else {
                        console.log(`${currentHost.name} is already naked!`);
                    }
                    keys['5'] = false;
                }

                // Check for suicide command (K key)
                if (keys['k']) {
                    if (currentHost) {
                        // Mark NPC as dead
                        currentHost.isDead = true;
                        currentHost.deathTime = Date.now();
                        currentHost.bloodParticles = [];

                        // Freeze position - body cannot move after death
                        currentHost.deathX = currentHost.x;
                        currentHost.deathZ = currentHost.z;

                        // Create blood cough particles
                        for (let i = 0; i < 20; i++) {
                            currentHost.bloodParticles.push({
                                x: currentHost.x,
                                y: currentHost.height * 0.8, // From mouth area
                                z: currentHost.z,
                                vx: (Math.random() - 0.5) * 200,
                                vy: Math.random() * 100 + 50,
                                vz: (Math.random() - 0.5) * 200,
                                life: 1.0
                            });
                        }

                        console.log(`${currentHost.name} has committed suicide!`);

                        // Spawn 2 village guards in response to the death
                        spawnGuardsForDeath(currentHost.x, currentHost.z);

                        // Shadow stays in the dead body
                        // Do NOT call releasePossession()
                    }
                    keys['k'] = false;
                }

                // Update ability cooldowns (check currentHost again in case it was released)
                if (currentHost && currentHost.abilityCooldowns) {
                    for (let i = 0; i < 4; i++) {
                        if (currentHost.abilityCooldowns[i] > 0) {
                            currentHost.abilityCooldowns[i] -= deltaTime * 1000;
                        }
                    }
                }
            } else {
                // Shadow form movement (first-person 3D) - FIXED to match projection
                const speed = shadow.speed;

                // Forward/backward (move along looking direction)
                if (keys.w) {
                    shadow.x -= Math.sin(shadow.angle) * speed * deltaTime;
                    shadow.z += Math.cos(shadow.angle) * speed * deltaTime;
                }
                if (keys.s) {
                    shadow.x += Math.sin(shadow.angle) * speed * deltaTime;
                    shadow.z -= Math.cos(shadow.angle) * speed * deltaTime;
                }

                // Strafe left/right (perpendicular to looking direction)
                if (keys.a) {
                    shadow.x -= Math.cos(shadow.angle) * speed * deltaTime;
                    shadow.z -= Math.sin(shadow.angle) * speed * deltaTime;
                }
                if (keys.d) {
                    shadow.x += Math.cos(shadow.angle) * speed * deltaTime;
                    shadow.z += Math.sin(shadow.angle) * speed * deltaTime;
                }

                // No world bounds - infinite expansion!

                // Energy stays full (infinite)
                shadowEnergy = 100;

                // Check for possession (can re-possess NPCs that were previously possessed)
                let canPossess = false;
                let nearestNPC = null;
                let nearestDist = Infinity;

                npcs.forEach(npc => {
                    // Can possess NPCs that are not currently being possessed
                    if (npc !== currentHost) {
                        const dx = npc.x - shadow.x;
                        const dz = npc.z - shadow.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);

                        if (dist < 50) { // Possession range
                            canPossess = true;
                            if (dist < nearestDist) {
                                nearestDist = dist;
                                nearestNPC = npc;
                            }
                        }
                    }
                });

                // Possess nearest NPC in range
                if (canPossess && keys[' '] && nearestNPC) {
                    possessNPC(nearestNPC);
                    keys[' '] = false;
                }

                // Show/hide possession prompt
                if (canPossess) {
                    document.getElementById('possessionPrompt').classList.add('show');
                } else {
                    document.getElementById('possessionPrompt').classList.remove('show');
                }
            }

            // Update NPCs (AI behavior - flee from shadow if visible)
            npcs.forEach(npc => {
                // Handle dead NPCs (from suicide)
                if (npc.isDead) {
                    // FREEZE POSITION - dead bodies cannot move
                    npc.x = npc.deathX;
                    npc.z = npc.deathZ;

                    // Worm animation removed (was causing errors)

                    // Update blood particles
                    if (npc.bloodParticles && npc.bloodParticles.length > 0) {
                        npc.bloodParticles = npc.bloodParticles.filter(p => {
                            p.x += p.vx * deltaTime;
                            p.y += p.vy * deltaTime;
                            p.z += p.vz * deltaTime;
                            p.vy -= 500 * deltaTime; // Gravity
                            p.life -= deltaTime * 2;
                            return p.life > 0 && p.y > 0;
                        });
                    }

                    // Collapse animation (body falls to ground over 2 seconds)
                    const timeSinceDeath = (Date.now() - npc.deathTime) / 1000;
                    if (!npc.collapseProgress) npc.collapseProgress = 0;
                    if (npc.collapseProgress < 1) {
                        npc.collapseProgress = Math.min(1, timeSinceDeath / 2);
                    }

                    // Dead bodies attract NPCs (crowd around but not too close)
                    if (!npc.corpseCrowdMap) npc.corpseCrowdMap = new Map();

                    return; // Skip normal AI for dead NPCs
                }

                // Skip NPCs that are currently being controlled by the shadow
                if (npc.currentlyControlled) {
                    return;
                }

                // Check if stun has expired
                if (npc.stunned && Date.now() >= npc.stunnedUntil) {
                    npc.stunned = false;
                    npc.speed = npc.originalSpeed; // Restore original speed
                    console.log(`${npc.name || 'NPC'} recovered from stun`);
                }

                // Update attack cooldown
                if (npc.attackCooldown > 0) {
                    npc.attackCooldown -= deltaTime;
                }

                // Remove dead NPCs later
                if (npc.health <= 0) {
                    return;
                }

                // POLICE AI - attack SHADOW ONLY
                // Guards who have been possessed become allies (don't attack shadow)
                if (npc.isPolice && !npc.everPossessed && !npc.currentlyControlled) {
                    const oldX = npc.x;
                    const oldZ = npc.z;

                    // Target the shadow (not NPCs)
                    let targetShadow = false;
                    let shadowDist = Infinity;
                    let dx = 0;
                    let dz = 0;

                    // Check if shadow is hidden
                    const shadowInDeadBody = isPossessing && currentHost && currentHost.isDead;
                    const shadowInLiveNPC = isPossessing && currentHost && !currentHost.isDead;

                    // Can only detect shadow if it's NOT possessing a live NPC
                    if (!shadowInDeadBody && !shadowInLiveNPC) {
                        // Always target shadow position when visible
                        dx = shadow.x - npc.x;
                        dz = shadow.z - npc.z;
                        shadowDist = Math.sqrt(dx * dx + dz * dz);

                        if (shadowDist < npc.detectionRange) {
                            targetShadow = true;
                        }
                    }

                    // If shadow is hidden in a live NPC, search/patrol
                    if (shadowInLiveNPC && !targetShadow) {
                        // Initialize patrol point if doesn't exist
                        if (!npc.patrolTarget) {
                            npc.patrolTarget = {
                                x: Math.random() * worldWidth,
                                z: Math.random() * worldDepth
                            };
                        }

                        // Move toward patrol point
                        const pdx = npc.patrolTarget.x - npc.x;
                        const pdz = npc.patrolTarget.z - npc.z;
                        const patrolDist = Math.sqrt(pdx * pdx + pdz * pdz);

                        if (patrolDist < 50) {
                            // Reached patrol point, pick new one
                            npc.patrolTarget = {
                                x: Math.random() * worldWidth,
                                z: Math.random() * worldDepth
                            };
                        } else {
                            // Move toward patrol point
                            npc.x += (pdx / patrolDist) * npc.speed * 0.5 * deltaTime; // Slower patrol speed
                            npc.z += (pdz / patrolDist) * npc.speed * 0.5 * deltaTime;
                        }
                    }

                    // Move toward and attack shadow (when visible)
                    if (targetShadow) {
                        // Use abilities strategically (AI) - very low probability per frame
                        if (npc.abilities && npc.abilityCooldowns) {
                            // Use Taser (ability 0) if close enough - 0.5% chance per frame
                            if (shadowDist < 150 && npc.abilityCooldowns[0] <= 0 && Math.random() < 0.005) {
                                useAbility(npc, 0);
                            }
                            // Use Shield Block (ability 1) if health is low - 0.3% chance per frame
                            if (npc.health < npc.maxHealth * 0.5 && npc.abilityCooldowns[1] <= 0 && Math.random() < 0.003) {
                                useAbility(npc, 1);
                            }
                            // Use Tackle (ability 2) if very close - 0.7% chance per frame
                            if (shadowDist < 100 && npc.abilityCooldowns[2] <= 0 && Math.random() < 0.007) {
                                useAbility(npc, 2);
                            }
                            // Use Call Backup (ability 3) very rarely - 0.1% chance per frame
                            if (npc.abilityCooldowns[3] <= 0 && Math.random() < 0.001) {
                                useAbility(npc, 3);
                            }
                        }

                        // Attack if in range
                        if (shadowDist < npc.attackRange && npc.attackCooldown <= 0 && !shadow.invulnerable) {
                            shadow.health = Math.max(0, shadow.health - 1);
                            shadow.invulnerable = true;
                            shadow.invulnerabilityTime = 0.5; // 0.5 seconds invulnerability
                            npc.attackCooldown = 1.0; // 1 second cooldown

                            // Visual damage feedback
                            shadow.damageFlash = 1.0; // Full intensity red flash
                            shadow.damageText = `-1 HP`;
                            shadow.damageTextTime = 1.5; // Show for 1.5 seconds

                            console.log('Village Guard hit shadow! Health:', shadow.health);

                            // Check if shadow died
                            if (shadow.health <= 0) {
                                shadowDeath();
                            }
                        } else if (shadowDist > npc.attackRange) {
                            // Move toward shadow
                            npc.x += (dx / shadowDist) * npc.speed * deltaTime;
                            npc.z += (dz / shadowDist) * npc.speed * deltaTime;
                        }
                    }

                    // Check collision
                    if (checkBuildingCollision(npc.x, npc.z, npc.radius)) {
                        npc.x = oldX;
                        npc.z = oldZ;
                    }

                    npc.x = Math.max(0, Math.min(worldWidth, npc.x));
                    npc.z = Math.max(0, Math.min(worldDepth, npc.z));

                    return; // Skip rest of AI for police
                }

                // NPCs that have been possessed before (but not currently controlled)
                if (npc.everPossessed) {
                    // Ensure mode exists (default to 'follow' if not set)
                    if (!npc.mode) {
                        npc.mode = 'follow';
                    }

                    // Store old position for collision checking
                    const oldX = npc.x;
                    const oldZ = npc.z;

                    // Execute behavior based on mode
                    if (npc.mode === 'stay') {
                        // STAY MODE - Do nothing, just stand still
                        // No movement at all
                    } else if (npc.mode === 'attack') {
                        // ATTACK MODE - Actively hunt police
                        let policeTarget = null;
                        let policeDist = Infinity;

                        npcs.forEach(otherNpc => {
                            if (otherNpc.isPolice && !otherNpc.everPossessed && otherNpc.health > 0) {
                                const dx = otherNpc.x - npc.x;
                                const dz = otherNpc.z - npc.z;
                                const dist = Math.sqrt(dx * dx + dz * dz);
                                if (dist < policeDist) {
                                    policeTarget = otherNpc;
                                    policeDist = dist;
                                }
                            }
                        });

                        if (policeTarget) {
                            const dx = policeTarget.x - npc.x;
                            const dz = policeTarget.z - npc.z;

                            // Attack if in range
                            if (policeDist < 80 && npc.attackCooldown <= 0) {
                                policeTarget.health -= npc.attackDamage;
                                npc.attackCooldown = 1.5;
                                console.log(npc.name, 'hit police! Police health:', policeTarget.health);
                            } else {
                                // Move toward police aggressively
                                npc.x += (dx / policeDist) * npc.speed * 1.2 * deltaTime; // 20% faster in attack mode
                                npc.z += (dz / policeDist) * npc.speed * 1.2 * deltaTime;
                            }
                        } else {
                            // No police found, switch to follow mode
                            npc.mode = 'follow';
                        }
                    } else if (npc.mode === 'follow') {
                        // FOLLOW MODE - Follow shadow, attack police only if they get close
                        let policeTarget = null;
                        let policeDist = Infinity;

                        // Check for nearby police (within defensive range)
                        npcs.forEach(otherNpc => {
                            if (otherNpc.isPolice && !otherNpc.everPossessed && otherNpc.health > 0) {
                                const dx = otherNpc.x - npc.x;
                                const dz = otherNpc.z - npc.z;
                                const dist = Math.sqrt(dx * dx + dz * dz);
                                if (dist < 200 && dist < policeDist) { // Only attack if close
                                    policeTarget = otherNpc;
                                    policeDist = dist;
                                }
                            }
                        });

                        // Defend if police nearby
                        if (policeTarget) {
                            const dx = policeTarget.x - npc.x;
                            const dz = policeTarget.z - npc.z;

                            // Attack if in range
                            if (policeDist < 80 && npc.attackCooldown <= 0) {
                                policeTarget.health -= npc.attackDamage;
                                npc.attackCooldown = 1.5;
                                console.log(npc.name, 'defended against police!');
                            } else {
                                // Move toward police to defend
                                npc.x += (dx / policeDist) * npc.speed * deltaTime;
                                npc.z += (dz / policeDist) * npc.speed * deltaTime;
                            }
                        } else {
                            // No police nearby, FOLLOW THE SHADOW
                            const dx = shadow.x - npc.x;
                            const dz = shadow.z - npc.z;
                            const distToShadow = Math.sqrt(dx * dx + dz * dz);

                            // Follow the shadow but stop when close enough
                            if (distToShadow > 80) {
                                const followSpeed = npc.speed * 0.8;
                                npc.x += (dx / distToShadow) * followSpeed * deltaTime;
                                npc.z += (dz / distToShadow) * followSpeed * deltaTime;
                            }
                        }
                    }

                    // Check collision with buildings
                    if (checkBuildingCollision(npc.x, npc.z, npc.radius)) {
                        npc.x = oldX;
                        npc.z = oldZ;
                    }

                    // Keep in world bounds
                    npc.x = Math.max(0, Math.min(worldWidth, npc.x));
                    npc.z = Math.max(0, Math.min(worldDepth, npc.z));

                    return; // Skip rest of AI logic
                }

                // Normal unpossessed NPC behavior
                if (true) {
                    // Store old position for collision checking
                    const oldX = npc.x;
                    const oldZ = npc.z;

                    // Update possession animation (fade out the back arch)
                    if (npc.possessionAnim > 0) {
                        npc.possessionAnim -= deltaTime * 0.2; // Fade out over ~5 seconds
                        npc.backArch = Math.max(0, npc.possessionAnim); // Gradually reduce arch
                        if (npc.possessionAnim <= 0) {
                            npc.possessionAnim = 0;
                            npc.backArch = 0;
                        }
                    }

                    // Update strip animation (multi-stage: reach up -> hold -> lower down)
                    if (npc.stripAnim > 0) {
                        npc.stripAnim -= deltaTime * 0.4; // Total duration ~2.5 seconds

                        // Animation stages:
                        // 1.0 - 0.7: Arms reaching up (0.75s)
                        // 0.7 - 0.3: Hold at top, removing clothes (1s)
                        // 0.3 - 0.0: Arms lowering down (0.75s)

                        if (npc.stripAnim > 0.7) {
                            // Stage 1: Reaching up
                            const reachProgress = (1.0 - npc.stripAnim) / 0.3; // 0 to 1
                            npc.leftArmAngle = reachProgress * Math.PI * 0.5;
                            npc.rightArmAngle = reachProgress * Math.PI * 0.5;
                        } else if (npc.stripAnim > 0.3) {
                            // Stage 2: Hold at top
                            npc.leftArmAngle = Math.PI * 0.5; // 90 degrees
                            npc.rightArmAngle = Math.PI * 0.5;
                        } else {
                            // Stage 3: Lowering down
                            const lowerProgress = npc.stripAnim / 0.3; // 1 to 0
                            npc.leftArmAngle = lowerProgress * Math.PI * 0.5;
                            npc.rightArmAngle = lowerProgress * Math.PI * 0.5;
                        }

                        if (npc.stripAnim <= 0) {
                            npc.stripAnim = 0;
                            npc.leftArmAngle = 0;
                            npc.rightArmAngle = 0;
                        }
                    }

                    // Check if there's a possessed NPC of opposite gender nearby
                    let attractedTo = null;
                    const attractionRange = 800; // Increased from 400 to 800
                    const attractionProbability = 0.8; // 80% chance of attraction

                    // Initialize attraction map if not exists (stores which NPCs this NPC is attracted to)
                    if (!npc.attractionMap) {
                        npc.attractionMap = new Map();
                    }

                    // Check currently controlled host
                    if (isPossessing && currentHost && currentHost.gender !== npc.gender) {
                        const dx = currentHost.x - npc.x;
                        const dz = currentHost.z - npc.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);

                        if (dist < attractionRange) {
                            // Check if attraction decision has been made for this NPC
                            if (!npc.attractionMap.has(currentHost.id)) {
                                // Make attraction decision (80% chance)
                                npc.attractionMap.set(currentHost.id, Math.random() < attractionProbability);
                            }

                            // Only attract if the random roll succeeded AND limit to 2 non-shadow NPCs
                            if (npc.attractionMap.get(currentHost.id)) {
                                // Count how many non-shadow NPCs are already attracted to currentHost
                                let nonShadowAttractedCount = 0;
                                npcs.forEach(otherNpc => {
                                    if (otherNpc !== npc && otherNpc.attractionMap && otherNpc.attractionMap.get(currentHost.id)) {
                                        const otherDist = Math.sqrt((currentHost.x - otherNpc.x) ** 2 + (currentHost.z - otherNpc.z) ** 2);
                                        if (otherDist < attractionRange && !otherNpc.everPossessed) {
                                            nonShadowAttractedCount++;
                                        }
                                    }
                                });

                                // Only allow attraction if less than 2 non-shadow NPCs are attracted
                                if (nonShadowAttractedCount < 2) {
                                    attractedTo = currentHost;
                                }
                            }
                        }
                    }

                    // Check ALL previously possessed NPCs of opposite gender (PERMANENT ATTRACTION with 80% probability)
                    if (!attractedTo) {
                        // First, count how many NPCs are attracted to each possessed NPC
                        const attractionCounts = new Map();

                        npcs.forEach(otherNpc => {
                            if (otherNpc.attractionMap) {
                                otherNpc.attractionMap.forEach((isAttracted, targetId) => {
                                    if (isAttracted) {
                                        // Check if the target is currently being attracted to
                                        const target = npcs.find(n => n.id === targetId);
                                        if (target && target !== npc) {
                                            const targetDist = Math.sqrt((target.x - otherNpc.x) ** 2 + (target.z - otherNpc.z) ** 2);
                                            if (targetDist < attractionRange && otherNpc !== npc) {
                                                attractionCounts.set(targetId, (attractionCounts.get(targetId) || 0) + 1);
                                            }
                                        }
                                    }
                                });
                            }
                        });

                        npcs.forEach(possessedNPC => {
                            if (possessedNPC.everPossessed && possessedNPC !== npc && possessedNPC.gender !== npc.gender) {
                                const dx = possessedNPC.x - npc.x;
                                const dz = possessedNPC.z - npc.z;
                                const dist = Math.sqrt(dx * dx + dz * dz);

                                if (dist < attractionRange) {
                                    // Check if attraction decision has been made for this possessed NPC
                                    if (!npc.attractionMap.has(possessedNPC.id)) {
                                        // Make attraction decision (80% chance)
                                        npc.attractionMap.set(possessedNPC.id, Math.random() < attractionProbability);
                                    }

                                    // Only attract if the random roll succeeded AND the target has less than 2 attracted NPCs
                                    // UNLESS those attracted NPCs are controlled by the shadow
                                    if (npc.attractionMap.get(possessedNPC.id)) {
                                        const currentCount = attractionCounts.get(possessedNPC.id) || 0;

                                        // Count how many attracted NPCs are NOT shadow-controlled
                                        let nonShadowAttractedCount = 0;
                                        npcs.forEach(otherNpc => {
                                            if (otherNpc !== npc && otherNpc.attractionMap && otherNpc.attractionMap.get(possessedNPC.id)) {
                                                const otherDist = Math.sqrt((possessedNPC.x - otherNpc.x) ** 2 + (possessedNPC.z - otherNpc.z) ** 2);
                                                if (otherDist < attractionRange && !otherNpc.everPossessed) {
                                                    nonShadowAttractedCount++;
                                                }
                                            }
                                        });

                                        // Only allow attraction if less than 2 non-shadow-controlled NPCs are attracted
                                        if (nonShadowAttractedCount < 2) {
                                            if (!attractedTo || dist < Math.sqrt((attractedTo.x - npc.x) ** 2 + (attractedTo.z - npc.z) ** 2)) {
                                                attractedTo = possessedNPC;
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    }

                    // CORPSE ATTRACTION: NPCs gather around dead bodies (but not too close)
                    if (!attractedTo && !npc.everPossessed) {
                        npcs.forEach(corpse => {
                            if (corpse.isDead && corpse !== npc) {
                                const dx = corpse.x - npc.x;
                                const dz = corpse.z - npc.z;
                                const dist = Math.sqrt(dx * dx + dz * dz);
                                const corpseViewRange = 500; // NPCs see corpses from 500 units away
                                const minCorpseDistance = 150; // Stay at least 150 units away

                                if (dist < corpseViewRange && dist > minCorpseDistance) {
                                    // Check if we've decided to be attracted to this corpse
                                    if (!npc.corpseAttractionMap) npc.corpseAttractionMap = new Map();

                                    if (!npc.corpseAttractionMap.has(corpse.id)) {
                                        // 60% chance to be curious about a dead body
                                        npc.corpseAttractionMap.set(corpse.id, Math.random() < 0.6);
                                    }

                                    if (npc.corpseAttractionMap.get(corpse.id)) {
                                        // Count how many NPCs are already crowding this corpse
                                        let crowdCount = 0;
                                        npcs.forEach(other => {
                                            if (other !== npc && other.corpseAttractionMap && other.corpseAttractionMap.get(corpse.id)) {
                                                const otherDist = Math.sqrt((corpse.x - other.x) ** 2 + (corpse.z - other.z) ** 2);
                                                if (otherDist < corpseViewRange) {
                                                    crowdCount++;
                                                }
                                            }
                                        });

                                        // Max 5 NPCs can crowd around a corpse
                                        if (crowdCount < 5) {
                                            // Move toward the corpse but maintain minimum distance
                                            attractedTo = corpse;
                                            npc.corpseAttraction = true;
                                        }
                                    }
                                }
                            }
                        });
                    }

                    // PASSIVE ATTRACTION: NPCs can be attracted to other NPCs based on their type
                    // This happens even when no one is possessed
                    if (!attractedTo && !npc.everPossessed) {
                        // Check all other NPCs for passive attraction
                        npcs.forEach(otherNpc => {
                            if (otherNpc !== npc && !otherNpc.everPossessed && otherNpc.type) {
                                const dx = otherNpc.x - npc.x;
                                const dz = otherNpc.z - npc.z;
                                const dist = Math.sqrt(dx * dx + dz * dz);

                                // Check if other NPC is within their attraction radius
                                const typeData = npcTypes[otherNpc.type];
                                if (typeData && typeData.attractionRadius && dist < typeData.attractionRadius) {
                                    // Roll for attraction based on type's attraction chance
                                    if (!npc.passiveAttractionMap) npc.passiveAttractionMap = new Map();

                                    if (!npc.passiveAttractionMap.has(otherNpc.id)) {
                                        // First time checking this NPC - roll for attraction
                                        npc.passiveAttractionMap.set(otherNpc.id, Math.random() < typeData.attractionChance);
                                    }

                                    // If attracted to this NPC type
                                    if (npc.passiveAttractionMap.get(otherNpc.id)) {
                                        // Check how many NPCs are already following this one
                                        let followersCount = 0;
                                        npcs.forEach(checkNpc => {
                                            if (checkNpc.passiveAttractionMap && checkNpc.passiveAttractionMap.get(otherNpc.id)) {
                                                const checkDist = Math.sqrt((otherNpc.x - checkNpc.x) ** 2 + (otherNpc.z - checkNpc.z) ** 2);
                                                if (checkDist < typeData.attractionRadius) {
                                                    followersCount++;
                                                }
                                            }
                                        });

                                        // Only allow max 2 passive followers per NPC
                                        if (followersCount < 3) {
                                            if (!attractedTo || dist < Math.sqrt((attractedTo.x - npc.x) ** 2 + (attractedTo.z - npc.z) ** 2)) {
                                                attractedTo = otherNpc;
                                                npc.passiveAttractionType = typeData.name;
                                                npc.passiveAttractionReason = typeData.attractionReason;
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    }

                    // PRIORITY 0.5: Check if NPC is "in love" - this overrides normal attraction
                    if (npc.inLoveWith) {
                        // Find the NPC they're in love with
                        const lovedOne = npcs.find(n => n.id === npc.inLoveWith);
                        if (lovedOne) {
                            // Override attractedTo with loved one
                            attractedTo = lovedOne;
                            npc.inLoveMode = true;
                        } else {
                            // Loved one doesn't exist anymore, clear the love
                            npc.inLoveWith = null;
                            npc.loveIntensity = null;
                            npc.inLoveMode = false;
                        }
                    } else {
                        npc.inLoveMode = false;
                    }

                    // PRIORITY 1: Attracted to opposite gender possessed NPC (or passively attracted or corpse or IN LOVE)
                    if (attractedTo) {
                        // Move toward the target
                        const dx = attractedTo.x - npc.x;
                        const dz = attractedTo.z - npc.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);

                        // If attracted to a corpse, maintain minimum distance of 150 units
                        // In love NPCs follow very closely (20 units), others maintain 50 units
                        const minDist = npc.corpseAttraction ? 150 : (npc.inLoveMode ? 20 : 50);

                        if (dist > minDist) {
                            // In love NPCs move FASTER and follow more closely
                            const moveSpeed = npc.inLoveMode ?
                                npc.speed * (npc.loveIntensity || 1.8) :
                                npc.speed * 0.6; // Normal attracted speed
                            npc.x += (dx / dist) * moveSpeed * deltaTime;
                            npc.z += (dz / dist) * moveSpeed * deltaTime;
                        } else if (npc.inLoveMode && dist > 5) {
                            // In love NPCs continuously adjust to stay close (within 5-20 units)
                            const adjustSpeed = npc.speed * 0.3;
                            npc.x += (dx / dist) * adjustSpeed * deltaTime;
                            npc.z += (dz / dist) * adjustSpeed * deltaTime;
                        }

                        npc.fleeing = false;
                        npc.attracted = true;

                        // Clear corpse attraction flag after use
                        if (npc.corpseAttraction && dist <= minDist) {
                            npc.corpseAttraction = false;
                        }
                    }
                    // PRIORITY 2: Check if NPC can see the shadow
                    // Shadow is invisible if we're possessing someone
                    // NPCs in love with Cupid (cupidLove flag) will IGNORE the shadow completely
                    // Police in love will also IGNORE the shadow
                    else if (!isPossessing && !npc.cupidLove && !(npc.isPolice && npc.inLoveWith)) {
                        // STUNNED NPCs CANNOT FLEE - they are completely stopped
                        if (npc.stunned) {
                            npc.fleeing = false;
                            npc.attracted = false;
                        } else {
                            // Calculate distance to shadow
                            const dx = npc.x - shadow.x;
                            const dz = npc.z - shadow.z;
                            const distToShadow = Math.sqrt(dx * dx + dz * dz);

                            // Detection range - NPCs can see shadow from 400 units away
                            const detectionRange = 400;

                            // Check if NPC can see the shadow (not blocked by buildings)
                            const canSeeShadow = checkLineOfSight(npc.x, npc.z, shadow.x, shadow.z);

                            if (distToShadow < detectionRange && canSeeShadow) {
                                // NPC sees the shadow - RUN AWAY!
                                // Calculate flee direction (away from shadow)
                                const fleeX = dx / distToShadow;
                                const fleeZ = dz / distToShadow;

                                // NPCs move 20% slower than shadow (shadow speed is 300)
                                const fleeSpeed = shadow.speed * 0.8; // 80% of shadow speed = 240

                                // Move away from shadow
                                npc.x += fleeX * fleeSpeed * deltaTime;
                                npc.z += fleeZ * fleeSpeed * deltaTime;

                                // Mark as fleeing (for visual feedback if needed)
                                npc.fleeing = true;
                                npc.attracted = false;
                            } else {
                                // Shadow too far OR blocked by building - stop running
                                npc.fleeing = false;
                                npc.attracted = false;
                            }
                        }
                    }
                    // PRIORITY 3: Normal wandering when shadow is hidden
                    else {
                        // Shadow is hidden (possessing someone) - behave normally
                        npc.fleeing = false;
                        npc.attracted = false;

                        // Random wandering when shadow not visible
                        if (!npc.targetX || !npc.targetZ || Math.random() < 0.01) {
                            npc.targetX = Math.random() * worldWidth;
                            npc.targetZ = Math.random() * worldDepth;
                        }

                        // Move toward target
                        const dx = npc.targetX - npc.x;
                        const dz = npc.targetZ - npc.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);

                        if (dist > 5) {
                            npc.x += (dx / dist) * npc.speed * deltaTime;
                            npc.z += (dz / dist) * npc.speed * deltaTime;
                        }
                    }

                    // Check collision with buildings - NPCs can't phase through
                    if (checkBuildingCollision(npc.x, npc.z, npc.radius)) {
                        // Revert to old position
                        npc.x = oldX;
                        npc.z = oldZ;

                        // If fleeing and hit a building, try to move around it
                        if (npc.fleeing) {
                            // Try moving perpendicular to flee direction
                            const dx = npc.x - shadow.x;
                            const dz = npc.z - shadow.z;
                            const dist = Math.sqrt(dx * dx + dz * dz);

                            // Try left
                            const perpX = -dz / dist;
                            const perpZ = dx / dist;
                            const fleeSpeed = shadow.speed * 0.8;

                            npc.x = oldX + perpX * fleeSpeed * deltaTime;
                            npc.z = oldZ + perpZ * fleeSpeed * deltaTime;

                            // If still colliding, try right
                            if (checkBuildingCollision(npc.x, npc.z, npc.radius)) {
                                npc.x = oldX - perpX * fleeSpeed * deltaTime;
                                npc.z = oldZ - perpZ * fleeSpeed * deltaTime;

                                // If still colliding, just stay put
                                if (checkBuildingCollision(npc.x, npc.z, npc.radius)) {
                                    npc.x = oldX;
                                    npc.z = oldZ;
                                }
                            }
                        } else {
                            // If wandering and hit building, pick new target
                            npc.targetX = Math.random() * worldWidth;
                            npc.targetZ = Math.random() * worldDepth;
                        }
                    }

                    // Keep in world bounds
                    npc.x = Math.max(0, Math.min(worldWidth, npc.x));
                    npc.z = Math.max(0, Math.min(worldDepth, npc.z));
                }
            });

            // Update UI
            document.getElementById('possessed').textContent = possessedCount;
            document.getElementById('energyBar').style.width = shadowEnergy + '%';
            document.getElementById('energyText').textContent = Math.floor(shadowEnergy);

            // Update health bar
            const healthPercent = (shadow.health / shadow.maxHealth) * 100;
            document.getElementById('healthBar').style.width = healthPercent + '%';
            document.getElementById('healthText').textContent = shadow.health + '/' + shadow.maxHealth;

            if (isPossessing && currentHost) {
                document.getElementById('stateDisplay').innerHTML = `<span>üßë Possessing ${currentHost.name}</span>`;

                // Update abilities UI
                updateAbilitiesUI();

                // Update mode selector UI
                updateModeUI();
            } else {
                document.getElementById('stateDisplay').innerHTML = `<span>üåë Shadow Form</span>`;

                // Hide abilities bar and mode selector
                document.getElementById('abilitiesBar').classList.remove('show');
                document.getElementById('modeSelector').classList.remove('show');
            }

            // Check if police should spawn
            if (!policeSpawned && possessedCount >= POLICE_SPAWN_THRESHOLD) {
                spawnPoliceSquad();
            }

            // Check win condition - all NPCs must have been possessed at least once
            const allPossessed = npcs.every(npc => npc.everPossessed);
            if (allPossessed && npcs.length > 0) {
                gameOver();
            }
        }

        function possessNPC(npc) {
            // Switch to third-person view for all NPCs when possessed
            camera.mode = 'third-person';
            camera.transitionProgress = 0; // Start transition

            // Female NPCs arc their back when possessed
            if (npc.gender === 'female') {
                npc.possessionAnim = 1.0; // Start animation
                npc.backArch = 1.0; // Full back arch
            }

            isPossessing = true;
            currentHost = npc;

            // Mark as currently possessed and track if ever possessed
            if (!npc.possessed) {
                npc.possessed = true;
                possessedCount++;

                // Check if this is a flight attendant
                if (npc.isFlightAttendant) {
                    flightAttendantsPossessed++;
                    console.log('Flight Attendant possessed! Total:', flightAttendantsPossessed);
                }
            }
            npc.everPossessed = true; // Track that this NPC has been possessed at some point
            npc.currentlyControlled = true; // Currently being controlled

            // If at military base, mark first possession (makes shadow visible when released)
            if (atMilitaryBase && !militaryBaseFirstPossession) {
                militaryBaseFirstPossession = true;
                console.log('üéñÔ∏è First possession at military base - shadow will be visible after release');
            }

            // Check airport unlock conditions
            checkAirportUnlock();
        }

        function checkAirportUnlock() {
            if (airportUnlocked) return; // Already unlocked

            // Check conditions: Either possess 2 flight attendants OR possess all villagers
            const allVillagersPossessed = npcs.every(npc => npc.everPossessed || npc.isFlightAttendant);

            if (flightAttendantsPossessed >= 2 || allVillagersPossessed) {
                airportUnlocked = true;
                if (airport) {
                    airport.locked = false;
                }
                console.log('üõ´ AIRPORT UNLOCKED! Enter to travel to the airport level!');

                // Show unlock message
                setTimeout(() => {
                    alert('üõ´ AIRPORT UNLOCKED! The airport entrance is now open. Walk into it to travel!');
                }, 500);
            }
        }

        function transitionToAirport() {
            console.log('‚úàÔ∏è Transitioning to Airport Level...');
            currentLevel = 'airport';

            // Save the currently possessed NPC to bring them along
            const savedHost = isPossessing && currentHost ? {
                ...currentHost,
                // Preserve important state
                possessed: currentHost.possessed,
                everPossessed: currentHost.everPossessed,
                clothingLevel: currentHost.clothingLevel,
                health: currentHost.health
            } : null;

            const wasInHost = isPossessing;

            // Clear existing NPCs and buildings
            npcs.length = 0;
            buildings.length = 0;
            possessedCount = 0;
            policeSpawned = false;

            // Reset shadow position
            shadow.x = worldWidth / 2;
            shadow.z = worldDepth / 2;

            // Reset all key states to prevent infinite movement
            for (let key in keys) {
                keys[key] = false;
            }

            // Initialize airport level
            initAirportLevel();

            // If we were possessing someone, bring them to airport and re-possess them
            if (wasInHost && savedHost) {
                // Place the saved NPC at spawn
                savedHost.x = worldWidth / 2;
                savedHost.z = worldDepth / 2;
                savedHost.id = 9999; // Special ID for transferred NPC

                // Add to NPCs array
                npcs.push(savedHost);

                // Re-possess the transferred NPC
                shadow.x = savedHost.x;
                shadow.z = savedHost.z;
                isPossessing = false; // Reset first
                currentHost = null;
                possessNPC(savedHost);

                console.log('‚úàÔ∏è Brought your host NPC to the airport:', savedHost.name);
                alert('‚úàÔ∏è Welcome to the Airport! You brought your host NPC with you!');
            } else {
                // Not possessing anyone, auto-possess a random airport NPC
                if (npcs.length > 0) {
                    const randomNPC = npcs[Math.floor(Math.random() * npcs.length)];
                    shadow.x = randomNPC.x;
                    shadow.z = randomNPC.z;
                    possessNPC(randomNPC);
                    console.log('üéØ Auto-possessed random NPC:', randomNPC.name);
                }
                alert('‚úàÔ∏è Welcome to the Airport! New NPCs with new abilities await...');
            }
        }

        function initAirportLevel() {
            // Airport NPC types with new abilities
            const airportNPCTypes = [
                {
                    color: '#FF6B6B',
                    name: 'Pilot',
                    speed: 100,
                    abilities: [
                        { key: '1', name: 'Autopilot', effect: 'mega_speed', cooldown: 5000 },
                        { key: '2', name: 'Air Traffic Control', effect: 'attract_all', cooldown: 4000 },
                        { key: '3', name: 'Barrel Roll', effect: 'spin_move', cooldown: 3000 },
                        { key: '4', name: 'Emergency Landing', effect: 'high_jump', cooldown: 6000 }
                    ]
                },
                {
                    color: '#4ECDC4',
                    name: 'Security Guard',
                    speed: 110,
                    abilities: [
                        { key: '1', name: 'Metal Detector', effect: 'reveal_map', cooldown: 8000 },
                        { key: '2', name: 'Scanner Beam', effect: 'camera_flash', cooldown: 2000 },
                        { key: '3', name: 'Lockdown', effect: 'stun_attack', cooldown: 7000 },
                        { key: '4', name: 'Patrol Rush', effect: 'speed_boost', cooldown: 4000 }
                    ]
                },
                {
                    color: '#95E1D3',
                    name: 'Baggage Handler',
                    speed: 85,
                    abilities: [
                        { key: '1', name: 'Luggage Toss', effect: 'show_off', cooldown: 3000 },
                        { key: '2', name: 'Conveyor Sprint', effect: 'super_speed', cooldown: 4000 },
                        { key: '3', name: 'Heavy Lift', effect: 'energy_burst', cooldown: 5000 },
                        { key: '4', name: 'Load Cart', effect: 'money_rain', cooldown: 6000 }
                    ]
                },
                {
                    color: '#F38181',
                    name: 'Airport Cleaner',
                    speed: 65,
                    abilities: [
                        { key: '1', name: 'Mop Spin', effect: 'spin_move', cooldown: 3000 },
                        { key: '2', name: 'Polish Floors', effect: 'charm_wave', cooldown: 5000 },
                        { key: '3', name: 'Vacuum Power', effect: 'attract_all', cooldown: 6000 },
                        { key: '4', name: 'Sanitize Spray', effect: 'camera_flash', cooldown: 2000 }
                    ]
                },
                {
                    color: '#AA96DA',
                    name: 'Gate Agent',
                    speed: 75,
                    abilities: [
                        { key: '1', name: 'Boarding Announcement', effect: 'alert_sound', cooldown: 4000 },
                        { key: '2', name: 'Final Call', effect: 'attract_all', cooldown: 7000 },
                        { key: '3', name: 'Upgrade Customer', effect: 'friendly_wave', cooldown: 3000 },
                        { key: '4', name: 'Gate Rush', effect: 'speed_boost', cooldown: 4000 }
                    ]
                }
            ];

            // Spawn airport NPCs
            const skinTones = ['#FDBCB4', '#F1C27D', '#E0AC69', '#D4A574', '#C68642', '#A67B5B', '#8D5524', '#6B4423'];
            const hairColors = ['#2C3E50', '#8B4513', '#654321', '#A0522D', '#FFD700', '#000000', '#4A4A4A', '#8B7355'];

            for (let i = 0; i < 25; i++) { // 25 airport NPCs
                const type = airportNPCTypes[Math.floor(Math.random() * airportNPCTypes.length)];
                const angle = (Math.PI * 2 * i) / 25;
                const distance = 200 + Math.random() * 600;
                const x = worldWidth / 2 + Math.cos(angle) * distance;
                const z = worldDepth / 2 + Math.sin(angle) * distance;
                const gender = Math.random() < 0.5 ? 'male' : 'female';

                const npc = {
                    x: x,
                    y: 0,
                    z: z,
                    vx: 0,
                    vz: 0,
                    radius: 30,
                    height: 170 + Math.random() * 30,
                    color: type.color,
                    name: type.name,
                    speed: type.speed,
                    possessed: false,
                    targetX: null,
                    targetZ: null,
                    skinTone: skinTones[Math.floor(Math.random() * skinTones.length)],
                    bodyType: ['slim', 'average', 'athletic'][Math.floor(Math.random() * 3)],
                    gender: gender,
                    hairStyle: gender === 'male' ? (Math.random() < 0.8 ? 'short' : 'bald') : ['long', 'ponytail'][Math.floor(Math.random() * 2)],
                    hairColor: hairColors[Math.floor(Math.random() * hairColors.length)],
                    personHeight: 20 + Math.random() * 15,
                    id: i,
                    possessionAnim: 0,
                    backArch: 0,
                    stripAnim: 0,
                    leftArmAngle: 0,
                    rightArmAngle: 0,
                    clothingLevel: 3,
                    type: type,
                    abilities: type.abilities,
                    abilityCooldowns: [0, 0, 0, 0],
                    activeEffects: [],
                    everPossessed: false,
                    currentlyControlled: false,
                    health: 100,
                    maxHealth: 100,
                    isPolice: false,
                    attackCooldown: 0,
                    attackDamage: 10,
                    mode: 'follow'
                };
                npcs.push(npc);
            }

            // Create airport terminal buildings
            for (let i = 0; i < 10; i++) {
                const bx = Math.random() * worldWidth;
                const bz = Math.random() * worldDepth;
                buildings.push({
                    x: bx,
                    y: 0,
                    z: bz,
                    width: 150 + Math.random() * 200,
                    height: 150 + Math.random() * 150,
                    depth: 150 + Math.random() * 200,
                    color: ['#CCCCCC', '#B0C4DE', '#D3D3D3', '#A9A9A9'][Math.floor(Math.random() * 4)], // Gray/steel colors
                    isAirport: false,
                    isTerminal: true
                });
            }

            document.getElementById('totalNPCs').textContent = 25;
            document.getElementById('objective').textContent = 'Possess all airport staff!';

            console.log('Airport level initialized: 25 NPCs, 10 terminal buildings');
        }

        function releasePossession() {
            if (currentHost) {
                // Update shadow position to current host's position before releasing
                shadow.x = currentHost.x;
                shadow.z = currentHost.z;
                // Set shadow at eye level (approximately mid-height of NPC)
                shadow.y = currentHost.height * 0.6; // Eye level is about 60% of NPC height

                currentHost.currentlyControlled = false; // No longer being controlled
                // Keep npc.possessed = true and npc.everPossessed = true
            }
            isPossessing = false;
            currentHost = null;

            // Switch back to first-person camera
            camera.mode = 'first-person';
        }

        // Transition to Military Base
        function transitionToMilitaryBase() {
            console.log('üéñÔ∏è Transitioning to MILITARY BASE...');
            currentLevel = 'military_base';
            atMilitaryBase = true;

            // Clear existing NPCs and buildings
            npcs.length = 0;
            buildings.length = 0;
            possessedCount = 0;
            policeSpawned = false;

            // Reset shadow position
            shadow.x = worldWidth / 2;
            shadow.z = worldDepth / 2;

            // Reset all key states to prevent infinite movement
            for (let key in keys) {
                keys[key] = false;
            }

            // Initialize military base level
            initMilitaryBaseLevel();

            // Auto-possess a random NPC when entering new world
            if (npcs.length > 0) {
                const randomNPC = npcs[Math.floor(Math.random() * npcs.length)];
                shadow.x = randomNPC.x;
                shadow.z = randomNPC.z;
                possessNPC(randomNPC);
                console.log('üéØ Auto-possessed random NPC:', randomNPC.name);
            }

            alert('üéñÔ∏è Welcome to the MILITARY BASE! Only guards, police, and special love NPCs here!');
        }

        function initMilitaryBaseLevel() {
            // Military base buildings - bunkers, barracks, etc.
            const militaryBuildingCount = 15;
            const buildingColors = ['#556B2F', '#6B8E23', '#3B3B3B', '#4A4A4A'];

            for (let i = 0; i < militaryBuildingCount; i++) {
                const bx = Math.random() * worldWidth;
                const bz = Math.random() * worldDepth;

                // Ensure not too close to center spawn
                if (Math.abs(bx - worldWidth / 2) < 300 && Math.abs(bz - worldDepth / 2) < 300) {
                    continue;
                }

                const building = {
                    x: bx,
                    y: 0,
                    z: bz,
                    width: 80 + Math.random() * 120,
                    height: 100 + Math.random() * 150,
                    depth: 80 + Math.random() * 120,
                    color: buildingColors[Math.floor(Math.random() * buildingColors.length)],
                    isMilitary: true
                };
                buildings.push(building);
            }

            // Spawn NPCs for military base
            const skinTones = ['#FDBCB4', '#F1C27D', '#E0AC69', '#D4A574', '#C68642', '#A67B5B', '#8D5524', '#6B4423'];
            const hairColors = ['#2C3E50', '#8B4513', '#654321', '#A0522D', '#000000', '#4A4A4A', '#8B7355'];
            const hairStyles = ['short', 'long', 'ponytail', 'bald', 'curly', 'wavy'];
            const bodyTypes = ['slim', 'athletic', 'average', 'muscular'];

            // Get love-themed NPC types (Bard, Cupid, Matchmaker, Love Priest) + Herbalist
            const loveTypes = npcTypes.filter(type =>
                type.name === 'Bard' || type.name === 'Cupid' || type.name === 'Matchmaker' ||
                type.name === 'Love Priest' || type.name === 'Herbalist'
            );

            // Spawn 25 love-themed NPCs (increased from 10 for better gameplay)
            for (let i = 0; i < 25; i++) {
                const type = loveTypes[Math.floor(Math.random() * loveTypes.length)];
                let x, z;
                let attempts = 0;

                do {
                    const angle = (Math.PI * 2 * i) / 25 + Math.random() * 0.3;
                    const distance = 300 + Math.random() * 500;
                    x = worldWidth / 2 + Math.cos(angle) * distance;
                    z = worldDepth / 2 + Math.sin(angle) * distance;
                    attempts++;
                } while (checkBuildingCollision(x, z, 30) && attempts < 50);

                const gender = Math.random() < 0.5 ? 'male' : 'female';
                let hairStyle;
                if (gender === 'male') {
                    hairStyle = Math.random() < 0.8 ? 'short' : 'bald';
                } else {
                    hairStyle = hairStyles[Math.floor(Math.random() * hairStyles.length)];
                }

                const npc = {
                    x: x,
                    y: 0,
                    z: z,
                    vx: 0,
                    vz: 0,
                    radius: 30,
                    height: 170 + Math.random() * 30,
                    color: type.color,
                    name: type.name,
                    speed: type.speed,
                    possessed: false,
                    targetX: null,
                    targetZ: null,
                    skinTone: skinTones[Math.floor(Math.random() * skinTones.length)],
                    skinColor: skinTones[Math.floor(Math.random() * skinTones.length)],
                    bodyType: bodyTypes[Math.floor(Math.random() * bodyTypes.length)],
                    gender: gender,
                    hairStyle: hairStyle,
                    hairColor: hairColors[Math.floor(Math.random() * hairColors.length)],
                    personHeight: 20 + Math.random() * 15,
                    id: 5000 + i,
                    possessionAnim: 0,
                    backArch: 0,
                    stripAnim: 0,
                    leftArmAngle: 0,
                    rightArmAngle: 0,
                    clothingLevel: 3,
                    type: type,
                    abilities: type.abilities,
                    abilityCooldowns: [0, 0, 0, 0],
                    activeEffects: [],
                    everPossessed: false,
                    currentlyControlled: false,
                    health: 100,
                    maxHealth: 100,
                    isPolice: false,
                    attackCooldown: 0,
                    attackDamage: 10,
                    mode: 'follow'
                };
                npcs.push(npc);
            }

            // Spawn 20 Village Guards and Police
            const policeAbilities = [
                { key: '1', name: 'Taser', effect: 'stun_attack', cooldown: 3000 },
                { key: '2', name: 'Shield Block', effect: 'defense_boost', cooldown: 5000 },
                { key: '3', name: 'Tackle', effect: 'melee_attack', cooldown: 2000 },
                { key: '4', name: 'Call Backup', effect: 'police_siren', cooldown: 8000 }
            ];

            for (let i = 0; i < 20; i++) {
                let x, z;
                let attempts = 0;

                do {
                    const angle = (Math.PI * 2 * i) / 20 + Math.random() * 0.2;
                    const distance = 400 + Math.random() * 600;
                    x = worldWidth / 2 + Math.cos(angle) * distance;
                    z = worldDepth / 2 + Math.sin(angle) * distance;
                    attempts++;
                } while (checkBuildingCollision(x, z, 30) && attempts < 50);

                const gender = Math.random() < 0.5 ? 'male' : 'female';

                const guard = {
                    x: x,
                    y: 0,
                    z: z,
                    vx: 0,
                    vz: 0,
                    radius: 30,
                    height: 180,
                    color: '#8B4513',
                    name: 'Military Guard',
                    speed: 120,
                    possessed: false,
                    targetX: null,
                    targetZ: null,
                    skinTone: '#FDBCB4',
                    skinColor: '#FDBCB4',
                    bodyType: 'athletic',
                    gender: gender,
                    hairStyle: 'short',
                    hairColor: '#2C3E50',
                    personHeight: 30,
                    id: 6000 + i,
                    possessionAnim: 0,
                    backArch: 0,
                    stripAnim: 0,
                    leftArmAngle: 0,
                    rightArmAngle: 0,
                    clothingLevel: 3,
                    type: { name: 'Military Guard', color: '#8B4513', speed: 120, abilities: policeAbilities },
                    abilities: policeAbilities,
                    abilityCooldowns: [0, 0, 0, 0],
                    activeEffects: [],
                    everPossessed: false,
                    currentlyControlled: false,
                    health: 150,
                    maxHealth: 150,
                    isPolice: true,
                    attackCooldown: 0,
                    attackDamage: 30,
                    attackRange: 80,
                    detectionRange: 700,
                    mode: 'patrol'
                };
                npcs.push(guard);
                policeSquad.push(guard);
            }

            console.log(`üéñÔ∏è Military Base initialized: ${npcs.length} NPCs spawned`);
        }

        // Spawn police squad
        function spawnPoliceSquad() {
            if (policeSpawned) return;
            policeSpawned = true;

            console.log('üö® POLICE SQUAD SPAWNED! üö®');

            // Police abilities - combat focused
            const policeAbilities = [
                { key: '1', name: 'Taser', effect: 'stun_attack', cooldown: 3000 },
                { key: '2', name: 'Shield Block', effect: 'defense_boost', cooldown: 5000 },
                { key: '3', name: 'Tackle', effect: 'melee_attack', cooldown: 2000 },
                { key: '4', name: 'Call Backup', effect: 'police_siren', cooldown: 8000 }
            ];

            // Spawn 5 police officers around the shadow's position
            for (let i = 0; i < 5; i++) {
                // Keep trying to find a valid spawn position (not inside buildings)
                let x, z;
                let attempts = 0;
                const maxAttempts = 50;

                do {
                    const angle = (Math.PI * 2 * i) / 5 + Math.random() * 0.3;
                    const distance = 400 + Math.random() * 100; // Spawn 400-500 units away
                    x = shadow.x + Math.cos(angle) * distance;
                    z = shadow.z + Math.sin(angle) * distance;
                    attempts++;
                } while (checkBuildingCollision(x, z, 30) && attempts < maxAttempts);

                const policeOfficer = {
                    x: x,
                    y: 0,
                    z: z,
                    vx: 0,
                    vz: 0,
                    radius: 30,
                    height: 180,
                    color: '#8B4513', // Village guard brown
                    name: 'Village Guard',
                    speed: 120, // Faster than normal NPCs
                    possessed: false,
                    targetX: null,
                    targetZ: null,
                    skinTone: '#FDBCB4',
                    bodyType: 'athletic',
                    gender: Math.random() < 0.5 ? 'male' : 'female',
                    hairStyle: 'short',
                    hairColor: '#2C3E50',
                    personHeight: 30,
                    id: 1000 + i,
                    possessionAnim: 0,
                    backArch: 0,
                    // Strip animation state
                    stripAnim: 0,
                    leftArmAngle: 0,
                    rightArmAngle: 0,
                    // Clothing state (0 = naked, 1 = underwear, 2 = partial clothes, 3 = fully clothed)
                    clothingLevel: 3,
                    type: { name: 'Village Guard', color: '#8B4513', speed: 120, abilities: policeAbilities },
                    abilities: policeAbilities,
                    abilityCooldowns: [3000, 5000, 2000, 8000], // Start with cooldowns active to prevent instant spam
                    activeEffects: [],
                    everPossessed: false,
                    currentlyControlled: false,
                    // Police-specific stats
                    health: 150, // More health than civilians
                    maxHealth: 150,
                    isPolice: true,
                    attackCooldown: 0,
                    attackDamage: 25, // More damage
                    attackRange: 80,
                    detectionRange: 600 // Can detect shadow from farther
                };
                npcs.push(policeOfficer);
                policeSquad.push(policeOfficer);
            }
        }

        // Spawn 2 village guards in response to a death
        function spawnGuardsForDeath(deathX, deathZ, callerIsPossessed = false) {
            console.log('üö® 2 Village Guards responding to incident! üö®');

            // Police abilities - combat focused
            const policeAbilities = [
                { key: '1', name: 'Taser', effect: 'stun_attack', cooldown: 3000 },
                { key: '2', name: 'Shield Block', effect: 'defense_boost', cooldown: 5000 },
                { key: '3', name: 'Tackle', effect: 'melee_attack', cooldown: 2000 },
                { key: '4', name: 'Call Backup', effect: 'police_siren', cooldown: 8000 }
            ];

            // Get unique IDs for the new guards
            const baseId = 1000 + npcs.filter(n => n.isPolice).length;

            // Spawn 2 guards near the death location
            for (let i = 0; i < 2; i++) {
                // Keep trying to find a valid spawn position (not inside buildings)
                let x, z;
                let attempts = 0;
                const maxAttempts = 50;

                do {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 300 + Math.random() * 200; // Spawn 300-500 units away
                    x = deathX + Math.cos(angle) * distance;
                    z = deathZ + Math.sin(angle) * distance;
                    attempts++;
                } while (checkBuildingCollision(x, z, 30) && attempts < maxAttempts);

                const guard = {
                    x: x,
                    y: 0,
                    z: z,
                    vx: 0,
                    vz: 0,
                    radius: 30,
                    height: 180,
                    color: '#8B4513', // Village guard brown
                    name: 'Village Guard',
                    speed: 120, // Faster than normal NPCs
                    possessed: false,
                    targetX: null,
                    targetZ: null,
                    skinColor: '#FDBCB4',
                    skinTone: '#FDBCB4',
                    bodyType: 'athletic',
                    gender: Math.random() < 0.5 ? 'male' : 'female',
                    hairStyle: 'short',
                    hairColor: '#2C3E50',
                    personHeight: 30,
                    id: baseId + i,
                    possessionAnim: 0,
                    backArch: 0,
                    stripAnim: 0,
                    leftArmAngle: 0,
                    rightArmAngle: 0,
                    clothingLevel: 3,
                    type: { name: 'Village Guard', color: '#8B4513', speed: 120, abilities: policeAbilities },
                    abilities: policeAbilities,
                    abilityCooldowns: [3000, 5000, 2000, 8000], // Start with cooldowns active to prevent instant spam
                    activeEffects: [],
                    everPossessed: false,
                    currentlyControlled: false,
                    health: 150,
                    maxHealth: 150,
                    isPolice: true,
                    attackCooldown: 0,
                    attackDamage: 25,
                    attackRange: 80,
                    detectionRange: 600
                };

                // ONLY if called by a possessed police: 50% chance the backup guard is already infected
                if (callerIsPossessed && Math.random() < 0.5) {
                    guard.everPossessed = true;
                    guard.possessed = true;
                    guard.mode = 'follow'; // Follow the shadow/player
                    console.log(`‚ö†Ô∏è Backup guard ${guard.name} arrived already infected!`);
                } else {
                    console.log(`‚úÖ Backup guard ${guard.name} arrived clean`);
                }

                npcs.push(guard);
                policeSquad.push(guard);
            }

            // Mark that police have spawned (for game mechanics)
            policeSpawned = true;
        }

        // Use NPC ability
        function useAbility(npc, abilityIndex) {
            const ability = npc.abilities[abilityIndex];
            if (!ability) return;

            // Set cooldown
            npc.abilityCooldowns[abilityIndex] = ability.cooldown;

            // Execute effect
            executeEffect(npc, ability.effect, ability.name);

            console.log(`${npc.name} used ${ability.name}!`);
        }

        // Execute ability effect
        function executeEffect(npc, effectType, abilityName) {
            switch(effectType) {
                case 'attract_all':
                    // Attract all NPCs within range
                    activeEffects.push({
                        type: 'attract_all',
                        source: npc,
                        duration: 3000,
                        startTime: Date.now(),
                        radius: 500
                    });
                    break;

                case 'speed_boost':
                    // Temporary speed boost
                    const oldSpeed = npc.speed;
                    npc.speed *= 2;
                    setTimeout(() => { npc.speed = oldSpeed; }, 3000);
                    activeEffects.push({
                        type: 'speed_boost',
                        source: npc,
                        duration: 3000,
                        startTime: Date.now()
                    });
                    break;

                case 'money_rain':
                    // Visual money rain effect
                    activeEffects.push({
                        type: 'money_rain',
                        source: npc,
                        duration: 2000,
                        startTime: Date.now(),
                        particles: []
                    });
                    // Create money particles
                    for (let i = 0; i < 30; i++) {
                        activeEffects[activeEffects.length - 1].particles.push({
                            x: npc.x + (Math.random() - 0.5) * 200,
                            y: npc.height + 200 + Math.random() * 100,
                            z: npc.z + (Math.random() - 0.5) * 200,
                            vx: (Math.random() - 0.5) * 50,
                            vy: -100 - Math.random() * 50,
                            vz: (Math.random() - 0.5) * 50
                        });
                    }
                    break;

                case 'charm_wave':
                    // Charm wave that slows nearby NPCs
                    activeEffects.push({
                        type: 'charm_wave',
                        source: npc,
                        duration: 1500,
                        startTime: Date.now(),
                        radius: 0,
                        maxRadius: 400
                    });
                    break;

                case 'super_speed':
                    // Super speed boost
                    const originalSpeed = npc.speed;
                    npc.speed *= 3;
                    setTimeout(() => { npc.speed = originalSpeed; }, 4000);
                    activeEffects.push({
                        type: 'super_speed',
                        source: npc,
                        duration: 4000,
                        startTime: Date.now()
                    });
                    break;

                case 'high_jump':
                    // Jump effect (visual)
                    activeEffects.push({
                        type: 'high_jump',
                        source: npc,
                        duration: 1000,
                        startTime: Date.now(),
                        jumpHeight: 0
                    });
                    break;

                case 'energy_burst':
                    // Herbalist healing aura - pushes NPCs away AND heals shadow by 1 HP
                    npcs.forEach(otherNpc => {
                        if (otherNpc !== npc && !otherNpc.possessed) {
                            const dx = otherNpc.x - npc.x;
                            const dz = otherNpc.z - npc.z;
                            const dist = Math.sqrt(dx * dx + dz * dz);
                            if (dist < 300) {
                                otherNpc.x += (dx / dist) * 200;
                                otherNpc.z += (dz / dist) * 200;
                            }
                        }
                    });

                    // Heal the shadow by 1 HP
                    if (shadow.health < shadow.maxHealth) {
                        shadow.health = Math.min(shadow.maxHealth, shadow.health + 1);
                        console.log(`üíö Herbalist healing aura healed shadow! Health: ${shadow.health}/${shadow.maxHealth}`);
                    }

                    activeEffects.push({
                        type: 'energy_burst',
                        source: npc,
                        duration: 500,
                        startTime: Date.now(),
                        radius: 0
                    });
                    break;

                case 'flexibility':
                    // Flexibility pose animation
                    activeEffects.push({
                        type: 'flexibility',
                        source: npc,
                        duration: 2000,
                        startTime: Date.now()
                    });
                    break;

                case 'camera_flash':
                    // Camera flash effect
                    activeEffects.push({
                        type: 'camera_flash',
                        source: npc,
                        duration: 200,
                        startTime: Date.now(),
                        intensity: 1.0
                    });
                    break;

                case 'friendly_wave':
                    // Wave animation
                    activeEffects.push({
                        type: 'friendly_wave',
                        source: npc,
                        duration: 1500,
                        startTime: Date.now()
                    });
                    break;

                case 'reveal_map':
                    // Reveal all NPCs temporarily
                    activeEffects.push({
                        type: 'reveal_map',
                        source: npc,
                        duration: 5000,
                        startTime: Date.now()
                    });
                    break;

                case 'pose':
                    // Selfie pose
                    activeEffects.push({
                        type: 'pose',
                        source: npc,
                        duration: 2000,
                        startTime: Date.now()
                    });
                    break;

                case 'mega_speed':
                    // Mega speed boost
                    const baseSpeed = npc.speed;
                    npc.speed *= 4;
                    setTimeout(() => { npc.speed = baseSpeed; }, 3000);
                    activeEffects.push({
                        type: 'mega_speed',
                        source: npc,
                        duration: 3000,
                        startTime: Date.now()
                    });
                    break;

                case 'alert_sound':
                    // Alert sound wave
                    activeEffects.push({
                        type: 'alert_sound',
                        source: npc,
                        duration: 1000,
                        startTime: Date.now(),
                        waves: [0, 0, 0]
                    });
                    break;

                case 'spin_move':
                    // Spinning drift
                    activeEffects.push({
                        type: 'spin_move',
                        source: npc,
                        duration: 1500,
                        startTime: Date.now(),
                        rotation: 0
                    });
                    break;

                case 'show_off':
                    // Wheelie show-off
                    activeEffects.push({
                        type: 'show_off',
                        source: npc,
                        duration: 2000,
                        startTime: Date.now()
                    });
                    break;

                case 'shoot_love_arrow':
                    // Cupid's Love Arrow - shoots a projectile that makes FEMALE NPCs fall in love with Cupid
                    const chargePercent = Math.min(bowChargeTime / maxBowCharge, 1.0);
                    console.log(`üíò ${npc.name || 'Cupid'} shoots a love arrow! (Charge: ${Math.round(chargePercent * 100)}%)`);

                    // Get Cupid's facing direction based on camera angle if possessing
                    let arrowDirX, arrowDirY, arrowDirZ;
                    if (isPossessing && currentHost === npc) {
                        // Use shadow's angle and pitch for gun-style aiming
                        // Calculate 3D direction vector from angle and pitch
                        const horizontalLength = Math.cos(shadow.pitch); // How much of the vector is horizontal
                        arrowDirX = Math.sin(shadow.angle) * horizontalLength;
                        arrowDirY = -Math.sin(shadow.pitch); // Negative because positive pitch looks down
                        arrowDirZ = Math.cos(shadow.angle) * horizontalLength;
                    } else {
                        // Find nearest female NPC to shoot at (AI-controlled Cupid)
                        // At military base, can also target police
                        let nearestTarget = null;
                        let nearestDist = Infinity;
                        npcs.forEach(otherNpc => {
                            const canTargetPolice = atMilitaryBase && otherNpc.isPolice;
                            if (otherNpc !== npc && !otherNpc.everPossessed &&
                                (otherNpc.gender === 'female' || canTargetPolice)) {
                                const dx = otherNpc.x - npc.x;
                                const dz = otherNpc.z - npc.z;
                                const dist = Math.sqrt(dx * dx + dz * dz);
                                if (dist < nearestDist && dist < 800) {
                                    nearestTarget = otherNpc;
                                    nearestDist = dist;
                                }
                            }
                        });

                        if (nearestTarget) {
                            const dx = nearestTarget.x - npc.x;
                            const dy = (nearestTarget.height * 0.7) - (npc.height * 0.7); // Aim at chest height
                            const dz = nearestTarget.z - npc.z;
                            const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                            arrowDirX = dx / dist;
                            arrowDirY = dy / dist;
                            arrowDirZ = dz / dist;
                        } else {
                            // Default forward direction (horizontal)
                            arrowDirX = 1;
                            arrowDirY = 0;
                            arrowDirZ = 0;
                        }
                    }

                    // Arrow speed and range based on charge (50% to 150% power)
                    const chargePower = 0.5 + (chargePercent * 1.0); // 0.5 to 1.5
                    const arrowSpeed = 400 + (chargePercent * 400); // 400 to 800 speed
                    const arrowLifetime = 2.0 + (chargePercent * 3.0); // 2 to 5 seconds

                    // Create love arrow projectile with 3D direction
                    loveArrows.push({
                        x: npc.x,
                        y: npc.height * 0.7, // Shoot from chest height
                        z: npc.z,
                        dirX: arrowDirX,
                        dirY: arrowDirY || 0, // Vertical direction
                        dirZ: arrowDirZ,
                        speed: arrowSpeed,
                        shooter: npc,
                        shooterId: npc.id,
                        lifetime: arrowLifetime,
                        chargePower: chargePower,
                        trail: [] // Visual trail
                    });
                    break;

                case 'attract_opposite_gender':
                    // Bard's Love Song - attracts ALL opposite gender NPCs in range and makes them fall in love
                    // At military base, can also affect police
                    console.log(`üíï ${npc.name || 'Bard'} (${npc.gender}) is singing a love song!`);
                    console.log(`üíï Bard is at: (${Math.floor(npc.x)}, ${Math.floor(npc.z)})`);
                    let attractedCount = 0;
                    let checkedCount = 0;
                    let inRangeCount = 0;
                    npcs.forEach(otherNpc => {
                        if (otherNpc !== npc) {
                            checkedCount++;
                            const dx = otherNpc.x - npc.x;
                            const dz = otherNpc.z - npc.z;
                            const dist = Math.sqrt(dx * dx + dz * dz);

                            if (dist < 400) {
                                inRangeCount++;
                                // Attract ALL opposite gender NPCs (regardless of possession status)
                                // At military base, also include police
                                const canInclude = !otherNpc.isPolice || atMilitaryBase;
                                const oppositeGender = otherNpc.gender !== npc.gender;

                                if (oppositeGender && canInclude) {
                                    // Initialize attraction map if needed
                                    if (!otherNpc.attractionMap) otherNpc.attractionMap = new Map();

                                    // Make them fall in love - 100% attraction to the bard
                                    otherNpc.attractionMap.set(npc.id, true);

                                    // Mark as "in love" for stronger behavior
                                    otherNpc.inLoveWith = npc.id;
                                    otherNpc.loveIntensity = 1.8; // Move faster towards loved one

                                    attractedCount++;
                                    console.log(`üíò ${otherNpc.name || 'NPC'} (${otherNpc.gender}) fell in love with the Bard! (dist: ${Math.floor(dist)})`);
                                }
                            }
                        }
                    });

                    console.log(`üíï Love Song Results: ${checkedCount} NPCs checked, ${inRangeCount} in range, ${attractedCount} fell in love!`);
                    if (attractedCount === 0 && inRangeCount > 0) {
                        console.log(`‚ö†Ô∏è No one fell in love - check if any opposite gender NPCs in range!`);
                    }

                    activeEffects.push({
                        type: 'love_song',
                        source: npc,
                        duration: 2000,
                        startTime: Date.now(),
                        radius: 400
                    });
                    break;

                case 'push_all_away':
                    // Town Crier's Loud Shout - pushes all NPCs away
                    console.log(`üì£ ${npc.name || 'Town Crier'} shouts loudly!`);
                    npcs.forEach(otherNpc => {
                        // Push away all NPCs except possessed ones
                        if (otherNpc !== npc && !otherNpc.everPossessed) {
                            const dx = otherNpc.x - npc.x;
                            const dz = otherNpc.z - npc.z;
                            const dist = Math.sqrt(dx * dx + dz * dz);
                            if (dist < 350) { // 350 unit range
                                // Push away with force
                                const pushForce = 300;
                                otherNpc.x += (dx / dist) * pushForce;
                                otherNpc.z += (dz / dist) * pushForce;
                                console.log(`üí® ${otherNpc.name || 'NPC'} was pushed away by the shout!`);
                            }
                        }
                    });
                    activeEffects.push({
                        type: 'shout_wave',
                        source: npc,
                        duration: 1000,
                        startTime: Date.now(),
                        radius: 350
                    });
                    break;

                case 'mass_love_aura':
                    // Mass love effect - makes ALL NPCs in range fall in love with EACH OTHER (not just the caster)
                    // At military base, can also affect police
                    console.log(`üíñ ${npc.name || 'Love Caster'} creates a mass love aura!`);
                    let affectedCount = 0;
                    const npcsInRange = [];

                    // Find all NPCs in range
                    npcs.forEach(otherNpc => {
                        // At military base, include police; otherwise exclude them
                        const canInclude = !otherNpc.isPolice || atMilitaryBase;
                        if (otherNpc !== npc && canInclude) {
                            const dx = otherNpc.x - npc.x;
                            const dz = otherNpc.z - npc.z;
                            const dist = Math.sqrt(dx * dx + dz * dz);
                            if (dist < 500) { // 500 unit range
                                npcsInRange.push(otherNpc);
                            }
                        }
                    });

                    // Make each NPC fall in love with a random opposite gender NPC in range
                    npcsInRange.forEach(npc1 => {
                        const oppositeGender = npcsInRange.filter(n => n.gender !== npc1.gender && n !== npc1);
                        if (oppositeGender.length > 0) {
                            const loveTarget = oppositeGender[Math.floor(Math.random() * oppositeGender.length)];
                            if (!npc1.attractionMap) npc1.attractionMap = new Map();
                            npc1.attractionMap.set(loveTarget.id, true);
                            npc1.inLoveWith = loveTarget.id;
                            npc1.loveIntensity = 1.5;
                            affectedCount++;
                        }
                    });

                    console.log(`üíù Mass love aura affected ${affectedCount} NPCs!`);
                    activeEffects.push({
                        type: 'mass_love_explosion',
                        source: npc,
                        duration: 3000,
                        startTime: Date.now(),
                        radius: 500
                    });
                    break;

                case 'pair_npcs':
                    // Matchmaking - pairs up nearby NPCs
                    // At military base, can also affect police
                    console.log(`üíë ${npc.name || 'Matchmaker'} is making matches!`);
                    const unpaired = [];
                    npcs.forEach(otherNpc => {
                        // At military base, include police; otherwise exclude them
                        const canInclude = !otherNpc.isPolice || atMilitaryBase;
                        if (otherNpc !== npc && !otherNpc.inLoveWith && canInclude) {
                            const dx = otherNpc.x - npc.x;
                            const dz = otherNpc.z - npc.z;
                            const dist = Math.sqrt(dx * dx + dz * dz);
                            if (dist < 400) {
                                unpaired.push(otherNpc);
                            }
                        }
                    });

                    // Pair them up by opposite genders
                    let pairCount = 0;
                    const males = unpaired.filter(n => n.gender === 'male');
                    const females = unpaired.filter(n => n.gender === 'female');
                    const pairLimit = Math.min(males.length, females.length);

                    for (let i = 0; i < pairLimit; i++) {
                        const male = males[i];
                        const female = females[i];

                        // Make them fall in love with each other
                        if (!male.attractionMap) male.attractionMap = new Map();
                        if (!female.attractionMap) female.attractionMap = new Map();

                        male.attractionMap.set(female.id, true);
                        male.inLoveWith = female.id;
                        male.loveIntensity = 1.5;

                        female.attractionMap.set(male.id, true);
                        female.inLoveWith = male.id;
                        female.loveIntensity = 1.5;

                        pairCount++;
                    }

                    console.log(`üíï Matchmaker created ${pairCount} couples!`);
                    activeEffects.push({
                        type: 'matchmaking_hearts',
                        source: npc,
                        duration: 2000,
                        startTime: Date.now()
                    });
                    break;

                // POLICE ABILITIES
                case 'stun_attack':
                    // STOP ALL non-possessed NPCs in range (including civilians)
                    npcs.forEach(target => {
                        // Skip the user, and skip already possessed NPCs
                        if (target === npc || target.everPossessed) return;

                        const dx = target.x - npc.x;
                        const dz = target.z - npc.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        if (dist < 150) {
                            // Store original speed if not already stunned
                            if (!target.stunned) {
                                target.originalSpeed = target.speed;
                            }

                            // Apply FULL STOP effect
                            target.stunned = true;
                            target.stunnedUntil = Date.now() + 5000; // 5 second stop
                            target.speed = 0; // COMPLETE STOP
                            target.attackCooldown = 5.0; // Prevent attacks

                            console.log(`üõë ${target.name || 'NPC'} completely stopped by taser!`);
                        }
                    });
                    activeEffects.push({
                        type: 'stun_wave',
                        source: npc,
                        duration: 500,
                        startTime: Date.now()
                    });
                    break;

                case 'defense_boost':
                    // Increase health temporarily
                    const healthBoost = 50;
                    npc.health = Math.min(npc.maxHealth + healthBoost, npc.health + healthBoost);
                    npc.maxHealth += healthBoost;
                    setTimeout(() => {
                        npc.maxHealth -= healthBoost;
                        npc.health = Math.min(npc.health, npc.maxHealth);
                    }, 5000);
                    activeEffects.push({
                        type: 'shield',
                        source: npc,
                        duration: 5000,
                        startTime: Date.now()
                    });
                    break;

                case 'melee_attack':
                    // Powerful tackle attack
                    npcs.forEach(target => {
                        if ((target.isPolice && !target.everPossessed) || target === npc) return;
                        const dx = target.x - npc.x;
                        const dz = target.z - npc.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        if (dist < 100) {
                            target.health -= 50; // Heavy damage
                            // Knockback
                            target.x += (dx / dist) * 150;
                            target.z += (dz / dist) * 150;
                        }
                    });
                    break;

                case 'police_siren':
                    // Call for backup - spawn 2 new guards at the caller's position
                    console.log('üö® Calling for backup! 2 guards incoming! üö®');
                    // Pass whether this caller is possessed - only possessed police spawn infected backups
                    spawnGuardsForDeath(npc.x, npc.z, npc.everPossessed);

                    // Also give speed boost to all existing guards
                    npcs.forEach(officer => {
                        if (officer.isPolice && !officer.everPossessed) {
                            officer.speed *= 1.5;
                            setTimeout(() => { officer.speed /= 1.5; }, 8000);
                        }
                    });
                    activeEffects.push({
                        type: 'siren',
                        source: npc,
                        duration: 8000,
                        startTime: Date.now()
                    });
                    break;
            }
        }

        // Update abilities UI
        function updateAbilitiesUI() {
            if (!isPossessing || !currentHost) return;

            const abilitiesBar = document.getElementById('abilitiesBar');
            abilitiesBar.classList.add('show');

            // Update each ability button
            for (let i = 0; i < 4; i++) {
                const ability = currentHost.abilities[i];
                const abilityBtn = document.getElementById(`ability${i + 1}`);
                const cooldownBar = document.getElementById(`cooldown${i + 1}`);
                const abilityName = abilityBtn.querySelector('.ability-name');

                if (ability) {
                    abilityName.textContent = ability.name;

                    // Update cooldown display
                    const cooldownRemaining = currentHost.abilityCooldowns[i];
                    const cooldownPercent = Math.max(0, (cooldownRemaining / ability.cooldown) * 100);

                    cooldownBar.style.width = cooldownPercent + '%';

                    if (cooldownRemaining > 0) {
                        abilityBtn.classList.add('on-cooldown');
                    } else {
                        abilityBtn.classList.remove('on-cooldown');
                    }
                }
            }

            // Update strip button
            const stripButton = document.getElementById('stripButton');
            const stripName = stripButton.querySelector('.ability-name');
            const clothingStates = ['Naked', 'Underwear', 'Partial', 'Clothed'];
            stripName.textContent = `Strip (${clothingStates[currentHost.clothingLevel]})`;
        }

        // Update mode selector UI
        function updateModeUI() {
            if (!isPossessing || !currentHost) return;

            const modeSelector = document.getElementById('modeSelector');
            modeSelector.classList.add('show');

            // Update active state
            const modeStay = document.getElementById('modeStay');
            const modeFollow = document.getElementById('modeFollow');
            const modeAttack = document.getElementById('modeAttack');

            modeStay.classList.remove('active');
            modeFollow.classList.remove('active');
            modeAttack.classList.remove('active');

            if (currentHost.mode === 'stay') {
                modeStay.classList.add('active');
            } else if (currentHost.mode === 'follow') {
                modeFollow.classList.add('active');
            } else if (currentHost.mode === 'attack') {
                modeAttack.classList.add('active');
            }
        }

        // Update active effects
        function updateEffects(deltaTime) {
            const currentTime = Date.now();

            // Remove expired effects
            for (let i = activeEffects.length - 1; i >= 0; i--) {
                const effect = activeEffects[i];
                const elapsed = currentTime - effect.startTime;

                if (elapsed >= effect.duration) {
                    activeEffects.splice(i, 1);
                    continue;
                }

                // Update effect-specific properties
                switch(effect.type) {
                    case 'charm_wave':
                        effect.radius = (elapsed / effect.duration) * effect.maxRadius;
                        break;

                    case 'high_jump':
                        const jumpProgress = elapsed / effect.duration;
                        effect.jumpHeight = Math.sin(jumpProgress * Math.PI) * 100;
                        effect.source.y = effect.jumpHeight;
                        break;

                    case 'energy_burst':
                        effect.radius = (elapsed / effect.duration) * 300;
                        break;

                    case 'money_rain':
                        effect.particles.forEach(p => {
                            p.x += p.vx * deltaTime;
                            p.y += p.vy * deltaTime;
                            p.z += p.vz * deltaTime;
                            p.vy -= 200 * deltaTime; // Gravity
                        });
                        break;

                    case 'spin_move':
                        effect.rotation = (elapsed / effect.duration) * Math.PI * 4;
                        break;

                    case 'alert_sound':
                        effect.waves = [
                            (elapsed / effect.duration) * 200,
                            Math.max(0, (elapsed - 300) / effect.duration) * 200,
                            Math.max(0, (elapsed - 600) / effect.duration) * 200
                        ];
                        break;
                }
            }
        }

        // Update love arrows
        function updateLoveArrows(deltaTime) {
            for (let i = loveArrows.length - 1; i >= 0; i--) {
                const arrow = loveArrows[i];

                // Update lifetime
                arrow.lifetime -= deltaTime;
                if (arrow.lifetime <= 0) {
                    loveArrows.splice(i, 1);
                    continue;
                }

                // Move arrow in 3D (including vertical movement)
                arrow.x += arrow.dirX * arrow.speed * deltaTime;
                arrow.y += (arrow.dirY || 0) * arrow.speed * deltaTime;
                arrow.z += arrow.dirZ * arrow.speed * deltaTime;

                // Add trail point
                arrow.trail.push({ x: arrow.x, y: arrow.y, z: arrow.z, time: Date.now() });
                // Keep only last 10 trail points
                if (arrow.trail.length > 10) {
                    arrow.trail.shift();
                }

                // Check collision with NPCs
                for (let j = 0; j < npcs.length; j++) {
                    const npc = npcs[j];

                    // Skip shooter, already possessed NPCs, and ONLY target female NPCs
                    // At military base, can also affect police
                    const canAffectPolice = atMilitaryBase && npc.isPolice;
                    if (npc.id === arrow.shooterId || npc.everPossessed ||
                        (npc.gender !== 'female' && !canAffectPolice)) continue;

                    const dx = npc.x - arrow.x;
                    const dy = (npc.height * 0.5) - arrow.y; // Check if arrow is at NPC's height
                    const dz = npc.z - arrow.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    const verticalDist = Math.abs(dy);

                    // Check if arrow hit the NPC (within radius horizontally and within height)
                    if (dist < npc.radius + 20 && verticalDist < npc.height) {
                        // Arrow hit! Make FEMALE NPC fall in love with Cupid (will ignore shadow)
                        if (!npc.attractionMap) npc.attractionMap = new Map();
                        npc.attractionMap.set(arrow.shooterId, true);
                        npc.inLoveWith = arrow.shooterId;
                        npc.loveIntensity = 1.8; // Move even faster (was 1.5)
                        npc.cupidLove = true; // Special flag: immune to shadow, only follows Cupid

                        console.log(`üíò ${npc.name || 'Female NPC'} was struck by Cupid's arrow! She now only loves Cupid!`);

                        // Create heart particle effect at hit location
                        activeEffects.push({
                            type: 'love_hit',
                            x: npc.x,
                            y: npc.height * 0.8,
                            z: npc.z,
                            duration: 1000,
                            startTime: Date.now()
                        });

                        // Remove arrow
                        loveArrows.splice(i, 1);
                        break;
                    }
                }

                // Check collision with buildings
                if (checkBuildingCollision(arrow.x, arrow.z, 10)) {
                    loveArrows.splice(i, 1);
                }
            }
        }

        // 3D projection helper - SUPPORTS BOTH FIRST-PERSON AND THIRD-PERSON
        function project3D(worldX, worldY, worldZ) {
            // Calculate camera position based on mode
            let camX = shadow.x;
            let camY = shadow.y;
            let camZ = shadow.z;
            let camAngle = shadow.angle;
            let camPitch = shadow.pitch;

            // If in third-person mode, position camera behind the current host
            if (camera.transitionProgress > 0 && isPossessing && currentHost) {
                // Calculate position behind the NPC based on current view angle
                // Camera follows the player's rotation so they can still look around
                const thirdPersonX = currentHost.x + Math.sin(shadow.angle) * camera.thirdPersonDistance;
                const thirdPersonY = camera.thirdPersonHeight;
                const thirdPersonZ = currentHost.z - Math.cos(shadow.angle) * camera.thirdPersonDistance;

                // In third-person, use the player's pitch but slightly angled down to see the NPC
                const thirdPersonPitch = shadow.pitch - 0.3; // Slightly angled down

                // Interpolate between first-person and third-person based on transition progress
                const t = camera.transitionProgress;
                camX = shadow.x + (thirdPersonX - shadow.x) * t;
                camY = shadow.y + (thirdPersonY - shadow.y) * t;
                camZ = shadow.z + (thirdPersonZ - shadow.z) * t;
                camPitch = shadow.pitch + (thirdPersonPitch - shadow.pitch) * t;
            }

            // Translate to camera space
            let dx = worldX - camX;
            let dy = worldY - camY;
            let dz = worldZ - camZ;

            // Rotate around Y axis (yaw) - camera rotation
            const cosY = Math.cos(camAngle);
            const sinY = Math.sin(camAngle);
            const tmpX = dx * cosY + dz * sinY;
            const tmpZ = -dx * sinY + dz * cosY;
            dx = tmpX;
            dz = tmpZ;

            // Rotate around X axis (pitch) - looking up/down
            const cosX = Math.cos(camPitch);
            const sinX = Math.sin(camPitch);
            const tmpY = dy * cosX - dz * sinX;
            const finalZ = dy * sinX + dz * cosX;
            dy = tmpY;

            // Check if behind camera (Z should be positive = in front)
            if (finalZ <= 1) return null;

            // Perspective projection
            const scale = 400; // Projection scale
            const screenX = (dx / finalZ) * scale + canvas.width / 2;
            const screenY = -(dy / finalZ) * scale + canvas.height / 2; // Negative because screen Y is inverted

            return {
                x: screenX,
                y: screenY,
                z: finalZ,
                scale: scale / finalZ
            };
        }

        // Draw game (First-Person 3D View)
        function draw() {
            // Clear canvas with gradient sky
            const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            skyGradient.addColorStop(0, '#0f3460');
            skyGradient.addColorStop(0.5, '#16213e');
            skyGradient.addColorStop(1, '#2a2a3e');
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Debug info
            ctx.fillStyle = '#fff';
            ctx.font = '14px Arial';
            ctx.fillText(`Pos: (${Math.floor(shadow.x)}, ${Math.floor(shadow.y)}, ${Math.floor(shadow.z)})`, 10, canvas.height - 140);
            ctx.fillText(`Angle: ${shadow.angle.toFixed(2)}, Pitch: ${shadow.pitch.toFixed(2)}`, 10, canvas.height - 120);
            ctx.fillText(`Camera: ${camera.mode} (transition: ${camera.transitionProgress.toFixed(2)})`, 10, canvas.height - 100);
            ctx.fillText(`Keys: W=${keys.w} A=${keys.a} S=${keys.s} D=${keys.d}`, 10, canvas.height - 80);
            ctx.fillText(`isPossessing: ${isPossessing}, currentHost: ${currentHost ? currentHost.name : 'none'}`, 10, canvas.height - 60);
            ctx.fillText(`gameRunning: ${gameRunning}, pointer locked: ${isPointerLocked}`, 10, canvas.height - 40);
            ctx.fillText(`NPCs: ${npcs.length}, Buildings: ${buildings.length}`, 10, canvas.height - 20);

            // Click to enable mouse look message (only show if not possessing)
            if (!isPointerLocked && !isPossessing) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(canvas.width / 2 - 200, canvas.height / 2 - 50, 400, 100);
                ctx.fillStyle = '#8a2be2';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('CLICK TO ENABLE MOUSE LOOK', canvas.width / 2, canvas.height / 2);
                ctx.font = '16px Arial';
                ctx.fillStyle = '#fff';
                ctx.fillText('Use WASD to move after clicking', canvas.width / 2, canvas.height / 2 + 30);
                ctx.textAlign = 'left';
            }

            // Draw ground plane
            const horizonY = canvas.height / 2 - Math.tan(shadow.pitch) * (canvas.height / 2);
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, horizonY, canvas.width, canvas.height - horizonY);

            // Draw ground grid for depth perception
            ctx.strokeStyle = 'rgba(138, 43, 226, 0.2)';
            ctx.lineWidth = 2;

            // Draw grid lines receding into distance
            for (let i = -10; i <= 10; i++) {
                // Parallel lines
                const startZ = 50;
                const endZ = camera.renderDistance;
                const offsetX = i * 200;

                const start = project3D(shadow.x + offsetX, 0, shadow.z + startZ);
                const end = project3D(shadow.x + offsetX, 0, shadow.z + endZ);

                if (start && end) {
                    ctx.beginPath();
                    ctx.moveTo(start.x, start.y);
                    ctx.lineTo(end.x, end.y);
                    ctx.stroke();
                }
            }

            // Perpendicular lines
            for (let i = 1; i <= 20; i++) {
                const z = i * 200;
                const leftX = -2000;
                const rightX = 2000;

                const left = project3D(shadow.x + leftX, 0, shadow.z + z);
                const right = project3D(shadow.x + rightX, 0, shadow.z + z);

                if (left && right) {
                    ctx.beginPath();
                    ctx.moveTo(left.x, left.y);
                    ctx.lineTo(right.x, right.y);
                    ctx.stroke();
                }
            }

            // Collect and sort all 3D objects by distance
            const renderObjects = [];

            // Add buildings
            buildings.forEach(building => {
                const dx = building.x - shadow.x;
                const dz = building.z - shadow.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist < camera.renderDistance) {
                    renderObjects.push({
                        type: 'building',
                        obj: building,
                        dist: dist
                    });
                }
            });

            // Add NPCs
            let npcInRange = 0;
            npcs.forEach(npc => {
                const dx = npc.x - shadow.x;
                const dz = npc.z - shadow.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist < camera.renderDistance) {
                    npcInRange++;
                    renderObjects.push({
                        type: 'npc',
                        obj: npc,
                        dist: dist
                    });
                }
            });

            // Debug NPC info
            ctx.fillStyle = '#00FF00';
            ctx.font = '14px Arial';
            ctx.fillText(`NPCs in range: ${npcInRange} / ${npcs.length}`, 10, canvas.height - 100);

            // Sort by distance (furthest first for painter's algorithm)
            renderObjects.sort((a, b) => b.dist - a.dist);

            // Debug: count visible objects
            let buildingsRendered = 0;
            let npcsRendered = 0;

            // Render all objects
            renderObjects.forEach(item => {
                if (item.type === 'building') {
                    drawBuilding3D(item.obj);
                    buildingsRendered++;
                } else if (item.type === 'npc') {
                    drawNPC3D(item.obj);
                    npcsRendered++;
                }
            });

            // Debug: show render count
            ctx.fillStyle = '#fff';
            ctx.font = '14px Arial';
            ctx.fillText(`Rendering: ${buildingsRendered} buildings, ${npcsRendered} NPCs`, 10, canvas.height - 80);
            ctx.fillText(`NPC draw calls: ${npcDrawCalls}`, 10, canvas.height - 120);
            npcDrawCalls = 0; // Reset for next frame

            // Draw crosshair
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            if (!isPossessing) {
                // Shadow form crosshair (purple)
                ctx.strokeStyle = 'rgba(138, 43, 226, 0.8)';
                ctx.lineWidth = 2;
                const size = 10;

                ctx.beginPath();
                ctx.moveTo(centerX - size, centerY);
                ctx.lineTo(centerX + size, centerY);
                ctx.moveTo(centerX, centerY - size);
                ctx.lineTo(centerX, centerY + size);
                ctx.stroke();

                // Crosshair circle
                ctx.beginPath();
                ctx.arc(centerX, centerY, 3, 0, Math.PI * 2);
                ctx.stroke();
            } else if (isPossessing && currentHost && currentHost.name === 'Cupid') {
                // Cupid's special bow crosshair (pink heart-shaped)
                ctx.strokeStyle = '#FF69B4';
                ctx.fillStyle = '#FF69B4';
                ctx.lineWidth = 2;
                const size = 12;

                // Draw heart-shaped crosshair
                ctx.beginPath();
                ctx.moveTo(centerX - size, centerY);
                ctx.lineTo(centerX + size, centerY);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(centerX, centerY - size);
                ctx.lineTo(centerX, centerY + size);
                ctx.stroke();

                // Center dot
                ctx.beginPath();
                ctx.arc(centerX, centerY, 2, 0, Math.PI * 2);
                ctx.fill();

                // Outer aiming circle
                ctx.globalAlpha = 0.5;
                ctx.beginPath();
                ctx.arc(centerX, centerY, 8, 0, Math.PI * 2);
                ctx.stroke();
                ctx.globalAlpha = 1.0;
            }

            // Draw bow charge indicator for Cupid
            if (bowCharging && isPossessing && currentHost && currentHost.name === 'Cupid') {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const chargePercent = Math.min(bowChargeTime / maxBowCharge, 1.0);

                // Draw charging arc around crosshair
                ctx.save();
                ctx.strokeStyle = `rgba(255, 105, 180, ${0.5 + chargePercent * 0.5})`;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(centerX, centerY, 30 + (chargePercent * 20), -Math.PI / 2, -Math.PI / 2 + (chargePercent * Math.PI * 2));
                ctx.stroke();

                // Draw charge percentage text
                ctx.fillStyle = '#FF69B4';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#FF1493';
                ctx.shadowBlur = 10;
                ctx.fillText(`${Math.round(chargePercent * 100)}%`, centerX, centerY - 60);

                // Draw "BOW CHARGING" text
                ctx.font = 'bold 16px Arial';
                ctx.fillText('üèπ CHARGING', centerX, centerY - 80);

                // Draw expanding pink circle when fully charged
                if (chargePercent >= 1.0) {
                    const pulseSize = 50 + Math.sin(Date.now() / 100) * 10;
                    ctx.strokeStyle = 'rgba(255, 105, 180, 0.8)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, pulseSize, 0, Math.PI * 2);
                    ctx.stroke();
                }

                ctx.restore();
            }

            // Draw damage flash overlay
            if (shadow.damageFlash > 0) {
                ctx.fillStyle = `rgba(255, 0, 0, ${shadow.damageFlash * 0.4})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // Draw damage text
            if (shadow.damageText && shadow.damageTextTime > 0) {
                const alpha = Math.min(1, shadow.damageTextTime / 0.5); // Fade out in last 0.5s
                ctx.save();
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Shadow for text
                ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                ctx.shadowBlur = 10;
                ctx.shadowOffsetX = 3;
                ctx.shadowOffsetY = 3;

                ctx.fillStyle = `rgba(255, 50, 50, ${alpha})`;
                ctx.fillText(shadow.damageText, canvas.width / 2, canvas.height / 2 - 100);

                // Health remaining text
                ctx.font = 'bold 36px Arial';
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.fillText(`Health: ${shadow.health}/${shadow.maxHealth}`, canvas.width / 2, canvas.height / 2 - 50);

                ctx.restore();
            }

            // Draw active effects
            drawEffects();

            // Shadow overlay (ethereal effect in first-person)
            if (!isPossessing) {
                // Vignette effect for shadow form - always show so player can see themselves
                const vignette = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, canvas.width / 4,
                                                          canvas.width / 2, canvas.height / 2, canvas.width / 1.5);
                vignette.addColorStop(0, 'rgba(138, 43, 226, 0)');
                vignette.addColorStop(1, 'rgba(138, 43, 226, 0.3)');
                ctx.fillStyle = vignette;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }

        // Draw visual effects
        function drawEffects() {
            activeEffects.forEach(effect => {
                const sourcePos = project3D(effect.source.x, effect.source.y, effect.source.z);
                if (!sourcePos) return;

                switch(effect.type) {
                    case 'speed_boost':
                    case 'super_speed':
                    case 'mega_speed':
                        // Speed lines behind the NPC
                        ctx.strokeStyle = effect.type === 'mega_speed' ? 'rgba(255, 200, 0, 0.6)' :
                                         effect.type === 'super_speed' ? 'rgba(255, 100, 0, 0.5)' :
                                         'rgba(138, 43, 226, 0.4)';
                        ctx.lineWidth = 3;
                        for (let i = 0; i < 5; i++) {
                            const offset = i * 30;
                            ctx.beginPath();
                            ctx.moveTo(sourcePos.x - offset, sourcePos.y - 20);
                            ctx.lineTo(sourcePos.x - offset - 50, sourcePos.y - 20);
                            ctx.stroke();
                        }
                        break;

                    case 'charm_wave':
                        // Expanding circle wave
                        const charmPos = project3D(effect.source.x, 0, effect.source.z);
                        if (charmPos) {
                            ctx.strokeStyle = 'rgba(255, 105, 180, 0.6)';
                            ctx.lineWidth = 4;
                            const radius = (effect.radius / 400) * 200;
                            ctx.beginPath();
                            ctx.arc(charmPos.x, charmPos.y, radius, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                        break;

                    case 'energy_burst':
                        // Expanding energy ring
                        const burstPos = project3D(effect.source.x, effect.source.height / 2, effect.source.z);
                        if (burstPos) {
                            ctx.strokeStyle = 'rgba(0, 255, 255, 0.7)';
                            ctx.lineWidth = 5;
                            const burstRadius = (effect.radius / 300) * 150;
                            ctx.beginPath();
                            ctx.arc(burstPos.x, burstPos.y, burstRadius, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                        break;

                    case 'camera_flash':
                        // Full screen white flash
                        ctx.fillStyle = `rgba(255, 255, 255, ${effect.intensity * 0.8})`;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        break;

                    case 'money_rain':
                        // Falling money particles
                        effect.particles.forEach(p => {
                            const particlePos = project3D(p.x, p.y, p.z);
                            if (particlePos) {
                                ctx.fillStyle = '#2ECC40';
                                ctx.font = 'bold 20px Arial';
                                ctx.fillText('$', particlePos.x, particlePos.y);
                            }
                        });
                        break;

                    case 'alert_sound':
                        // Sound waves emanating
                        const soundPos = project3D(effect.source.x, effect.source.height, effect.source.z);
                        if (soundPos) {
                            effect.waves.forEach(waveRadius => {
                                if (waveRadius > 0) {
                                    ctx.strokeStyle = `rgba(255, 255, 0, ${1 - waveRadius / 200})`;
                                    ctx.lineWidth = 3;
                                    ctx.beginPath();
                                    ctx.arc(soundPos.x, soundPos.y, waveRadius, 0, Math.PI * 2);
                                    ctx.stroke();
                                }
                            });
                        }
                        break;

                    case 'high_jump':
                        // Jump arc indicator
                        ctx.strokeStyle = 'rgba(255, 165, 0, 0.6)';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        ctx.arc(sourcePos.x, sourcePos.y + 50, 30, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        break;

                    case 'reveal_map':
                        // Radar ping effect
                        const elapsed = Date.now() - effect.startTime;
                        const pingRadius = (elapsed % 1000) / 1000 * 300;
                        ctx.strokeStyle = `rgba(0, 255, 0, ${1 - pingRadius / 300})`;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(canvas.width / 2, canvas.height / 2, pingRadius, 0, Math.PI * 2);
                        ctx.stroke();
                        break;

                    case 'love_song':
                        // Pink expanding heart wave
                        const lovePos = project3D(effect.source.x, effect.source.height / 2, effect.source.z);
                        if (lovePos) {
                            const progress = (Date.now() - effect.startTime) / effect.duration;
                            const waveRadius = progress * 200;
                            ctx.strokeStyle = `rgba(255, 105, 180, ${1 - progress})`;
                            ctx.lineWidth = 4;
                            ctx.beginPath();
                            ctx.arc(lovePos.x, lovePos.y, waveRadius, 0, Math.PI * 2);
                            ctx.stroke();

                            // Draw hearts
                            ctx.fillStyle = `rgba(255, 182, 193, ${1 - progress})`;
                            ctx.font = 'bold 24px Arial';
                            for (let i = 0; i < 8; i++) {
                                const angle = (i / 8) * Math.PI * 2;
                                const heartX = lovePos.x + Math.cos(angle) * waveRadius;
                                const heartY = lovePos.y + Math.sin(angle) * waveRadius;
                                ctx.fillText('üíï', heartX, heartY);
                            }
                        }
                        break;

                    case 'shout_wave':
                        // Orange/red expanding shockwave
                        const shoutPos = project3D(effect.source.x, effect.source.height / 2, effect.source.z);
                        if (shoutPos) {
                            const progress = (Date.now() - effect.startTime) / effect.duration;
                            const waveRadius = progress * 180;
                            ctx.strokeStyle = `rgba(255, 69, 0, ${1 - progress})`;
                            ctx.lineWidth = 6;
                            ctx.beginPath();
                            ctx.arc(shoutPos.x, shoutPos.y, waveRadius, 0, Math.PI * 2);
                            ctx.stroke();

                            // Inner wave
                            ctx.strokeStyle = `rgba(255, 140, 0, ${0.8 * (1 - progress)})`;
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.arc(shoutPos.x, shoutPos.y, waveRadius * 0.7, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                        break;

                    case 'love_hit':
                        // Heart explosion when arrow hits
                        const hitPos = project3D(effect.x, effect.y, effect.z);
                        if (hitPos) {
                            const progress = (Date.now() - effect.startTime) / effect.duration;
                            const explosionRadius = progress * 80;

                            // Multiple expanding hearts
                            for (let i = 0; i < 8; i++) {
                                const angle = (i / 8) * Math.PI * 2;
                                const heartX = hitPos.x + Math.cos(angle) * explosionRadius;
                                const heartY = hitPos.y + Math.sin(angle) * explosionRadius;
                                ctx.fillStyle = `rgba(255, 105, 180, ${1 - progress})`;
                                ctx.font = `bold ${20 * (1 - progress * 0.5)}px Arial`;
                                ctx.fillText('üíï', heartX, heartY);
                            }
                        }
                        break;
                }
            });

            // Draw love arrows
            loveArrows.forEach(arrow => {
                // Draw arrow trail
                for (let i = 0; i < arrow.trail.length - 1; i++) {
                    const p1 = arrow.trail[i];
                    const p2 = arrow.trail[i + 1];
                    const pos1 = project3D(p1.x, p1.y, p1.z);
                    const pos2 = project3D(p2.x, p2.y, p2.z);

                    if (pos1 && pos2) {
                        const alpha = (i / arrow.trail.length) * 0.8;
                        ctx.strokeStyle = `rgba(255, 105, 180, ${alpha})`;
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.moveTo(pos1.x, pos1.y);
                        ctx.lineTo(pos2.x, pos2.y);
                        ctx.stroke();
                    }
                }

                // Draw arrow head (heart shape)
                const arrowPos = project3D(arrow.x, arrow.y, arrow.z);
                if (arrowPos) {
                    // Pink glowing heart
                    ctx.fillStyle = '#FF69B4';
                    ctx.font = 'bold 28px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    // Glow effect
                    ctx.shadowColor = '#FF1493';
                    ctx.shadowBlur = 15;
                    ctx.fillText('üíò', arrowPos.x, arrowPos.y);
                    ctx.shadowBlur = 0;

                    // Arrow shaft (pink line pointing in direction)
                    const shaftLength = 30;
                    const endX = arrowPos.x - arrow.dirX * shaftLength;
                    const endY = arrowPos.y;
                    ctx.strokeStyle = '#FF69B4';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(arrowPos.x, arrowPos.y);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                }
            });
        }

        // Draw airport entrance building
        function drawAirportBuilding(building) {
            const corners = [
                project3D(building.x, 0, building.z),
                project3D(building.x + building.width, 0, building.z),
                project3D(building.x + building.width, 0, building.z + building.depth),
                project3D(building.x, 0, building.z + building.depth),
                project3D(building.x, building.height, building.z),
                project3D(building.x + building.width, building.height, building.z),
                project3D(building.x + building.width, building.height, building.z + building.depth),
                project3D(building.x, building.height, building.z + building.depth)
            ];

            if (!corners.some(c => c !== null)) return;

            // Draw modern airport building
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;

            // Locked/unlocked color
            const buildingColor = building.locked ? '#8B0000' : '#4169E1'; // Red locked, blue unlocked

            // Front face
            if (corners[0] && corners[1] && corners[5] && corners[4]) {
                ctx.fillStyle = buildingColor;
                ctx.beginPath();
                ctx.moveTo(corners[0].x, corners[0].y);
                ctx.lineTo(corners[1].x, corners[1].y);
                ctx.lineTo(corners[5].x, corners[5].y);
                ctx.lineTo(corners[4].x, corners[4].y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // Draw "AIRPORT" text
                const centerX = (corners[0].x + corners[1].x) / 2;
                const centerY = (corners[0].y + corners[4].y) / 2;
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(building.locked ? 'üîí LOCKED' : '‚úàÔ∏è AIRPORT', centerX, centerY);
            }

            // Right face
            if (corners[1] && corners[2] && corners[6] && corners[5]) {
                ctx.fillStyle = darkenColor(buildingColor, 20);
                ctx.beginPath();
                ctx.moveTo(corners[1].x, corners[1].y);
                ctx.lineTo(corners[2].x, corners[2].y);
                ctx.lineTo(corners[6].x, corners[6].y);
                ctx.lineTo(corners[5].x, corners[5].y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }

            // Top
            if (corners[4] && corners[5] && corners[6] && corners[7]) {
                ctx.fillStyle = lightenColor(buildingColor, 30);
                ctx.beginPath();
                ctx.moveTo(corners[4].x, corners[4].y);
                ctx.lineTo(corners[5].x, corners[5].y);
                ctx.lineTo(corners[6].x, corners[6].y);
                ctx.lineTo(corners[7].x, corners[7].y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }
        }

        // Draw terminal building (modern airport terminal)
        function drawTerminalBuilding(building) {
            const corners = [
                project3D(building.x, 0, building.z),
                project3D(building.x + building.width, 0, building.z),
                project3D(building.x + building.width, 0, building.z + building.depth),
                project3D(building.x, 0, building.z + building.depth),
                project3D(building.x, building.height, building.z),
                project3D(building.x + building.width, building.height, building.z),
                project3D(building.x + building.width, building.height, building.z + building.depth),
                project3D(building.x, building.height, building.z + building.depth)
            ];

            if (!corners.some(c => c !== null)) return;

            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;

            // Modern glass/steel look
            // Front face
            if (corners[0] && corners[1] && corners[5] && corners[4]) {
                const gradient = ctx.createLinearGradient(corners[0].x, corners[0].y, corners[1].x, corners[1].y);
                gradient.addColorStop(0, darkenColor(building.color, 10));
                gradient.addColorStop(0.5, building.color);
                gradient.addColorStop(1, darkenColor(building.color, 5));
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.moveTo(corners[0].x, corners[0].y);
                ctx.lineTo(corners[1].x, corners[1].y);
                ctx.lineTo(corners[5].x, corners[5].y);
                ctx.lineTo(corners[4].x, corners[4].y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // Glass windows (grid pattern)
                drawModernWindows(corners[0], corners[1], corners[5], corners[4]);
            }

            // Right face
            if (corners[1] && corners[2] && corners[6] && corners[5]) {
                ctx.fillStyle = darkenColor(building.color, 15);
                ctx.beginPath();
                ctx.moveTo(corners[1].x, corners[1].y);
                ctx.lineTo(corners[2].x, corners[2].y);
                ctx.lineTo(corners[6].x, corners[6].y);
                ctx.lineTo(corners[5].x, corners[5].y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }

            // Top
            if (corners[4] && corners[5] && corners[6] && corners[7]) {
                ctx.fillStyle = lightenColor(building.color, 20);
                ctx.beginPath();
                ctx.moveTo(corners[4].x, corners[4].y);
                ctx.lineTo(corners[5].x, corners[5].y);
                ctx.lineTo(corners[6].x, corners[6].y);
                ctx.lineTo(corners[7].x, corners[7].y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }
        }

        // Draw modern glass windows
        function drawModernWindows(bottomLeft, bottomRight, topRight, topLeft) {
            if (!bottomLeft || !bottomRight || !topRight || !topLeft) return;

            const faceWidth = Math.abs(bottomRight.x - bottomLeft.x);
            const faceHeight = Math.abs(topLeft.y - bottomLeft.y);

            if (faceWidth < 30 || faceHeight < 30) return;

            // Large glass panels
            ctx.fillStyle = 'rgba(135, 206, 235, 0.3)'; // Light blue glass
            const panelWidth = faceWidth * 0.8;
            const panelHeight = faceHeight * 0.8;
            const panelX = bottomLeft.x + (faceWidth - panelWidth) / 2;
            const panelY = bottomLeft.y - faceHeight * 0.9;

            ctx.fillRect(panelX, panelY, panelWidth, panelHeight);

            // Window frames
            ctx.strokeStyle = '#4A4A4A';
            ctx.lineWidth = 2;
            const rows = 3;
            const cols = 4;
            for (let r = 0; r <= rows; r++) {
                const y = panelY + (panelHeight * r / rows);
                ctx.beginPath();
                ctx.moveTo(panelX, y);
                ctx.lineTo(panelX + panelWidth, y);
                ctx.stroke();
            }
            for (let c = 0; c <= cols; c++) {
                const x = panelX + (panelWidth * c / cols);
                ctx.beginPath();
                ctx.moveTo(x, panelY);
                ctx.lineTo(x, panelY + panelHeight);
                ctx.stroke();
            }
        }

        // Draw building/hut/terminal in 3D
        function drawBuilding3D(building) {
            // Airport building (special rendering)
            if (building.isAirport) {
                drawAirportBuilding(building);
                return;
            }

            // Terminal buildings (modern airport buildings)
            if (building.isTerminal) {
                drawTerminalBuilding(building);
                return;
            }
            // Project all 8 corners of the building/hut base
            const wallHeight = building.height * 0.65; // Walls are 65% of total height
            const corners = [
                project3D(building.x, 0, building.z),
                project3D(building.x + building.width, 0, building.z),
                project3D(building.x + building.width, 0, building.z + building.depth),
                project3D(building.x, 0, building.z + building.depth),
                project3D(building.x, wallHeight, building.z),
                project3D(building.x + building.width, wallHeight, building.z),
                project3D(building.x + building.width, wallHeight, building.z + building.depth),
                project3D(building.x, wallHeight, building.z + building.depth)
            ];

            // Roof points - overhangs slightly beyond walls
            const overhang = building.width * 0.05;
            const roofFront = project3D(building.x + building.width / 2, building.height, building.z - overhang);
            const roofBack = project3D(building.x + building.width / 2, building.height, building.z + building.depth + overhang);
            const roofLeft = project3D(building.x - overhang, wallHeight, building.z + building.depth / 2);
            const roofRight = project3D(building.x + building.width + overhang, wallHeight, building.z + building.depth / 2);

            // Check if any corner is visible
            if (!corners.some(c => c !== null)) return;

            // Draw visible faces with darker outline
            ctx.strokeStyle = '#1a0f08';
            ctx.lineWidth = 2;

            // Front wall with texture
            if (corners[0] && corners[1] && corners[5] && corners[4]) {
                const gradient = ctx.createLinearGradient(corners[0].x, corners[0].y, corners[1].x, corners[1].y);
                gradient.addColorStop(0, darkenColor(building.color, 15));
                gradient.addColorStop(0.5, building.color);
                gradient.addColorStop(1, darkenColor(building.color, 8));
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.moveTo(corners[0].x, corners[0].y);
                ctx.lineTo(corners[1].x, corners[1].y);
                ctx.lineTo(corners[5].x, corners[5].y);
                ctx.lineTo(corners[4].x, corners[4].y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // Add wood plank texture to walls
                drawWoodPlanks(corners[0], corners[1], corners[5], corners[4], building.color);

                // Draw door on front face
                drawHutDoor(corners[0], corners[1], corners[5], corners[4]);
            }

            // Right wall
            if (corners[1] && corners[2] && corners[6] && corners[5]) {
                ctx.fillStyle = darkenColor(building.color, 25);
                ctx.beginPath();
                ctx.moveTo(corners[1].x, corners[1].y);
                ctx.lineTo(corners[2].x, corners[2].y);
                ctx.lineTo(corners[6].x, corners[6].y);
                ctx.lineTo(corners[5].x, corners[5].y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // Wood texture
                drawWoodPlanks(corners[1], corners[2], corners[6], corners[5], building.color);

                // Small window on side
                drawHutWindow(corners[1], corners[2], corners[6], corners[5]);
            }

            // Left wall
            if (corners[3] && corners[0] && corners[4] && corners[7]) {
                ctx.fillStyle = darkenColor(building.color, 30);
                ctx.beginPath();
                ctx.moveTo(corners[3].x, corners[3].y);
                ctx.lineTo(corners[0].x, corners[0].y);
                ctx.lineTo(corners[4].x, corners[4].y);
                ctx.lineTo(corners[7].x, corners[7].y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // Wood texture
                drawWoodPlanks(corners[3], corners[0], corners[4], corners[7], building.color);
            }

            // Back wall
            if (corners[2] && corners[3] && corners[7] && corners[6]) {
                ctx.fillStyle = darkenColor(building.color, 35);
                ctx.beginPath();
                ctx.moveTo(corners[2].x, corners[2].y);
                ctx.lineTo(corners[3].x, corners[3].y);
                ctx.lineTo(corners[7].x, corners[7].y);
                ctx.lineTo(corners[6].x, corners[6].y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }

            // Thatched roof with better coloring
            const thatchColor = '#8B7355'; // Straw/thatch color
            ctx.strokeStyle = '#1a0f08';
            ctx.lineWidth = 1.5;

            // Roof - right slope (visible from front-right)
            if (corners[5] && corners[6] && roofFront && roofBack) {
                const roofGrad = ctx.createLinearGradient(corners[5].x, corners[5].y, roofFront.x, roofFront.y);
                roofGrad.addColorStop(0, darkenColor(thatchColor, 20));
                roofGrad.addColorStop(0.5, thatchColor);
                roofGrad.addColorStop(1, darkenColor(thatchColor, 10));
                ctx.fillStyle = roofGrad;
                ctx.beginPath();
                ctx.moveTo(corners[5].x, corners[5].y);
                ctx.lineTo(roofFront.x, roofFront.y);
                ctx.lineTo(roofBack.x, roofBack.y);
                ctx.lineTo(corners[6].x, corners[6].y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // Thatch texture - horizontal lines
                ctx.strokeStyle = darkenColor(thatchColor, 35);
                ctx.lineWidth = 0.8;
                for (let i = 1; i < 8; i++) {
                    const t = i / 8;
                    const x1 = corners[5].x + (roofFront.x - corners[5].x) * t;
                    const y1 = corners[5].y + (roofFront.y - corners[5].y) * t;
                    const x2 = corners[6].x + (roofBack.x - corners[6].x) * t;
                    const y2 = corners[6].y + (roofBack.y - corners[6].y) * t;
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                }
            }

            // Roof - left slope
            if (corners[4] && corners[7] && roofFront && roofBack) {
                ctx.fillStyle = darkenColor(thatchColor, 25);
                ctx.strokeStyle = '#1a0f08';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(corners[4].x, corners[4].y);
                ctx.lineTo(roofFront.x, roofFront.y);
                ctx.lineTo(roofBack.x, roofBack.y);
                ctx.lineTo(corners[7].x, corners[7].y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }

            // Front triangular gable
            if (corners[4] && corners[5] && roofFront) {
                ctx.fillStyle = darkenColor(building.color, 10);
                ctx.beginPath();
                ctx.moveTo(corners[4].x, corners[4].y);
                ctx.lineTo(corners[5].x, corners[5].y);
                ctx.lineTo(roofFront.x, roofFront.y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }

            // Back triangular gable
            if (corners[6] && corners[7] && roofBack) {
                ctx.fillStyle = darkenColor(building.color, 15);
                ctx.beginPath();
                ctx.moveTo(corners[7].x, corners[7].y);
                ctx.lineTo(corners[6].x, corners[6].y);
                ctx.lineTo(roofBack.x, roofBack.y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }
        }

        // Draw wood plank texture on hut walls
        function drawWoodPlanks(bottomLeft, bottomRight, topRight, topLeft, baseColor) {
            if (!bottomLeft || !bottomRight || !topRight || !topLeft) return;

            const faceWidth = Math.abs(bottomRight.x - bottomLeft.x);
            const faceHeight = Math.abs(topLeft.y - bottomLeft.y);

            // Only draw planks if face is large enough
            if (faceWidth < 20 || faceHeight < 20) return;

            // Horizontal wood planks
            ctx.strokeStyle = darkenColor(baseColor, 40);
            ctx.lineWidth = 1.2;
            const numPlanks = Math.floor(faceHeight / 15);

            for (let i = 1; i < numPlanks; i++) {
                const t = i / numPlanks;
                const x1 = bottomLeft.x + (topLeft.x - bottomLeft.x) * t;
                const y1 = bottomLeft.y + (topLeft.y - bottomLeft.y) * t;
                const x2 = bottomRight.x + (topRight.x - bottomRight.x) * t;
                const y2 = bottomRight.y + (topRight.y - bottomRight.y) * t;

                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
        }

        // Draw door on hut front face
        function drawHutDoor(bottomLeft, bottomRight, topRight, topLeft) {
            if (!bottomLeft || !bottomRight || !topRight || !topLeft) return;

            const faceWidth = Math.abs(bottomRight.x - bottomLeft.x);
            const faceHeight = Math.abs(topLeft.y - bottomLeft.y);

            // Only draw door if face is large enough
            if (faceWidth < 20 || faceHeight < 30) return;

            // Door dimensions and position (centered, bottom of wall)
            const doorWidth = faceWidth * 0.3;
            const doorHeight = faceHeight * 0.6;
            const doorX = bottomLeft.x + faceWidth / 2 - doorWidth / 2;
            const doorY = bottomLeft.y - doorHeight;

            // Draw door
            ctx.fillStyle = '#3D2817'; // Dark brown wood
            ctx.fillRect(doorX, doorY, doorWidth, doorHeight);

            // Door frame
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 1.5;
            ctx.strokeRect(doorX, doorY, doorWidth, doorHeight);

            // Wood planks (horizontal lines)
            ctx.strokeStyle = '#2C1810';
            ctx.lineWidth = 1;
            for (let i = 1; i < 4; i++) {
                const y = doorY + (doorHeight * i / 4);
                ctx.beginPath();
                ctx.moveTo(doorX, y);
                ctx.lineTo(doorX + doorWidth, y);
                ctx.stroke();
            }
        }

        // Draw small window on hut side
        function drawHutWindow(bottomLeft, bottomRight, topRight, topLeft) {
            if (!bottomLeft || !bottomRight || !topRight || !topLeft) return;

            const faceWidth = Math.abs(bottomRight.x - bottomLeft.x);
            const faceHeight = Math.abs(topLeft.y - bottomLeft.y);

            // Only draw window if face is large enough
            if (faceWidth < 15 || faceHeight < 20) return;

            // Small window (upper center)
            const windowWidth = faceWidth * 0.25;
            const windowHeight = faceHeight * 0.2;
            const windowX = bottomLeft.x + faceWidth / 2 - windowWidth / 2;
            const windowY = bottomLeft.y - faceHeight * 0.7;

            // Window interior (dark or lit)
            const windowColor = Math.random() > 0.5 ? '#FFD700' : '#1a1a1a';
            ctx.fillStyle = windowColor;
            ctx.fillRect(windowX, windowY, windowWidth, windowHeight);

            // Window frame
            ctx.strokeStyle = '#3D2817';
            ctx.lineWidth = 1;
            ctx.strokeRect(windowX, windowY, windowWidth, windowHeight);

            // Window cross
            ctx.beginPath();
            ctx.moveTo(windowX + windowWidth / 2, windowY);
            ctx.lineTo(windowX + windowWidth / 2, windowY + windowHeight);
            ctx.moveTo(windowX, windowY + windowHeight / 2);
            ctx.lineTo(windowX + windowWidth, windowY + windowHeight / 2);
            ctx.stroke();
        }

        // Draw NPC in 3D - Ultra Realistic Human
        let npcDrawCalls = 0; // Debug counter
        function drawNPC3D(npc) {
            npcDrawCalls++;
            const isCurrentHost = (isPossessing && currentHost === npc);

            // Project center point first to check visibility
            const centerPos = project3D(npc.x, npc.height * 0.5, npc.z);
            if (!centerPos) return; // NPC completely out of view

            // Project detailed body points for realistic anatomy
            const feetPos = project3D(npc.x, 0, npc.z);
            const anklePos = project3D(npc.x, npc.height * 0.05, npc.z);
            const calfPos = project3D(npc.x, npc.height * 0.15, npc.z);
            const kneePos = project3D(npc.x, npc.height * 0.27, npc.z);
            const thighPos = project3D(npc.x, npc.height * 0.37, npc.z);
            const hipPos = project3D(npc.x, npc.height * 0.48, npc.z);
            const waistPos = project3D(npc.x, npc.height * 0.53, npc.z);
            const chestPos = project3D(npc.x, npc.height * 0.65, npc.z);
            const shoulderPos = project3D(npc.x, npc.height * 0.78, npc.z);
            const neckPos = project3D(npc.x, npc.height * 0.86, npc.z);
            const chinPos = project3D(npc.x, npc.height * 0.89, npc.z);
            const headTopPos = project3D(npc.x, npc.height, npc.z);

            // Use centerPos as fallback for any failed projections
            const safeFeetPos = feetPos || centerPos;
            const safeAnklePos = anklePos || centerPos;
            const safeCalfPos = calfPos || centerPos;
            const safeKneePos = kneePos || centerPos;
            const safeThighPos = thighPos || centerPos;
            const safeHipPos = hipPos || centerPos;
            const safeWaistPos = waistPos || centerPos;
            const safeChestPos = chestPos || centerPos;
            const safeShoulderPos = shoulderPos || centerPos;
            const safeNeckPos = neckPos || centerPos;
            const safeChinPos = chinPos || centerPos;
            const safeHeadTopPos = headTopPos || centerPos;

            const screenHeight = safeFeetPos.y - safeHeadTopPos.y;
            const screenWidth = screenHeight * 0.32; // More realistic slimmer proportions (was 0.35)

            // Skip if too small or invalid
            if (screenHeight < 10 || screenHeight > 10000) return;

            const centerX = safeFeetPos.x;

            // === HANDLE DEAD BODY RENDERING ===
            if (npc.isDead) {
                const collapseProgress = npc.collapseProgress || 0;
                const bodyY = safeFeetPos.y - screenHeight * 0.15 * (1 - collapseProgress);

                // Blood pool underneath
                if (collapseProgress >= 0.5) {
                    const bloodOpacity = Math.min(0.7, (collapseProgress - 0.5) * 1.4);
                    ctx.fillStyle = `rgba(100, 0, 0, ${bloodOpacity})`;
                    ctx.beginPath();
                    ctx.ellipse(centerX, safeFeetPos.y, screenHeight * 0.5, screenWidth * 1.2, 0, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Lying body (horizontal orientation)
                const bodyLength = screenHeight * 0.7;
                const bodyWidth = screenWidth * 0.6;

                // Legs
                ctx.fillStyle = npc.skinColor || '#D4A574';
                ctx.fillRect(centerX - bodyLength * 0.35, bodyY - bodyWidth * 0.15, bodyLength * 0.4, bodyWidth * 0.12);
                ctx.fillRect(centerX - bodyLength * 0.35, bodyY + bodyWidth * 0.03, bodyLength * 0.4, bodyWidth * 0.12);

                // Torso (with clothing color)
                const torsoColor = npc.color || '#4A4A4A';
                ctx.fillStyle = torsoColor;
                ctx.fillRect(centerX - bodyLength * 0.05, bodyY - bodyWidth * 0.2, bodyLength * 0.35, bodyWidth * 0.4);

                // Arms (splayed out)
                ctx.fillStyle = npc.skinColor || '#D4A574';
                ctx.fillRect(centerX + bodyLength * 0.1, bodyY - bodyWidth * 0.35, bodyLength * 0.25, bodyWidth * 0.08);
                ctx.fillRect(centerX + bodyLength * 0.1, bodyY + bodyWidth * 0.27, bodyLength * 0.25, bodyWidth * 0.08);

                // Head
                ctx.fillStyle = npc.skinColor || '#D4A574';
                ctx.beginPath();
                ctx.arc(centerX + bodyLength * 0.35, bodyY, screenWidth * 0.25, 0, Math.PI * 2);
                ctx.fill();

                // Hair on head
                if (npc.hairColor) {
                    ctx.fillStyle = npc.hairColor;
                    ctx.beginPath();
                    if (npc.gender === 'female') {
                        // Long hair spread out
                        ctx.ellipse(centerX + bodyLength * 0.35, bodyY, screenWidth * 0.35, screenWidth * 0.2, 0, 0, Math.PI * 2);
                    } else {
                        // Short hair
                        ctx.ellipse(centerX + bodyLength * 0.35, bodyY - screenWidth * 0.05, screenWidth * 0.2, screenWidth * 0.15, 0, 0, Math.PI * 2);
                    }
                    ctx.fill();
                }

                // Blood from mouth
                if (collapseProgress >= 0.3) {
                    ctx.fillStyle = `rgba(139, 0, 0, ${Math.min(0.9, collapseProgress)})`;
                    ctx.beginPath();
                    ctx.ellipse(centerX + bodyLength * 0.4, bodyY + screenWidth * 0.05, screenWidth * 0.15, screenWidth * 0.1, 0, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Skip normal rendering for dead
                return;
            }

            // Add subtle outline for depth
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.lineWidth = Math.max(1, screenHeight * 0.01);

            // Draw floor shadow
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.translate(safeFeetPos.x, safeFeetPos.y);
            ctx.scale(1, 0.3);
            ctx.beginPath();
            ctx.ellipse(0, 0, screenWidth * 0.6, screenWidth * 0.6, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // Draw possession aura
            if (npc.possessed) {
                ctx.strokeStyle = 'rgba(138, 43, 226, 0.8)';
                ctx.lineWidth = Math.max(3, screenHeight * 0.02);
                ctx.beginPath();
                ctx.ellipse(centerX, safeFeetPos.y - screenHeight * 0.5, screenWidth * 0.7, screenHeight * 0.6, 0, 0, Math.PI * 2);
                ctx.stroke();
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#8a2be2';
                ctx.stroke();
                ctx.shadowBlur = 0;
            }

            // === DRAW REALISTIC HUMAN (Simplified but detailed) ===

            // *** DRAW HAIR FIRST (BEHIND BODY) - Define head dimensions once ***
            const headWidthDim = screenWidth * 0.55; // Slightly wider head for realism
            const headHeightDim = screenHeight * 0.14; // More proportional head (was 0.16)
            const headCenterYPos = safeHeadTopPos.y + headHeightDim * 0.5;

            if (npc.gender === 'female') {
                // FEMALE: Very long hair extending to butt/hips - RENDERED BEHIND
                ctx.fillStyle = npc.hairColor;

                // Long flowing hair extending down to hip area
                const hairStartY = headCenterYPos + headHeightDim * 0.3;
                const hairEndY = safeWaistPos.y + (safeKneePos.y - safeWaistPos.y) * 0.2; // Hip level
                const hairWidthSize = screenWidth * 0.55;

                // Hair gradient for depth
                const hairGrad = ctx.createLinearGradient(
                    centerX - hairWidthSize / 2, hairStartY,
                    centerX + hairWidthSize / 2, hairStartY
                );
                hairGrad.addColorStop(0, darkenColor(npc.hairColor, 30));
                hairGrad.addColorStop(0.3, npc.hairColor);
                hairGrad.addColorStop(0.7, npc.hairColor);
                hairGrad.addColorStop(1, darkenColor(npc.hairColor, 30));
                ctx.fillStyle = hairGrad;

                // Draw long flowing hair BEHIND body
                ctx.beginPath();
                ctx.moveTo(centerX - headWidthDim * 0.45, hairStartY);
                ctx.quadraticCurveTo(
                    centerX - hairWidthSize * 0.5, (hairStartY + hairEndY) / 2,
                    centerX - hairWidthSize * 0.35, hairEndY
                );
                ctx.lineTo(centerX + hairWidthSize * 0.35, hairEndY);
                ctx.quadraticCurveTo(
                    centerX + hairWidthSize * 0.5, (hairStartY + hairEndY) / 2,
                    centerX + headWidthDim * 0.45, hairStartY
                );
                ctx.closePath();
                ctx.fill();

                // Add some hair strands for realism
                ctx.strokeStyle = darkenColor(npc.hairColor, 20);
                ctx.lineWidth = Math.max(1, screenHeight * 0.003);
                for (let i = -2; i <= 2; i++) {
                    const offset = i * hairWidthSize * 0.15;
                    ctx.beginPath();
                    ctx.moveTo(centerX + offset, hairStartY);
                    ctx.quadraticCurveTo(
                        centerX + offset * 1.1, (hairStartY + hairEndY) / 2,
                        centerX + offset * 0.9, hairEndY
                    );
                    ctx.stroke();
                }
            }

            // Walking animation for legs
            if (!npc.possessed) {
                const speed = Math.sqrt((npc.x - (npc.lastX || npc.x)) ** 2 + (npc.z - (npc.lastZ || npc.z)) ** 2);
                if (speed > 0.1) {
                    npc.walkCycle = (npc.walkCycle || 0) + speed * 0.1;
                } else {
                    npc.walkCycle = 0;
                }
                npc.lastX = npc.x;
                npc.lastZ = npc.z;
            }

            // Feet/Shoes
            const shoeWidth = screenWidth * 0.12;
            const shoeHeight = screenHeight * 0.05;
            ctx.fillStyle = '#2C2C2C';
            ctx.fillRect(centerX - screenWidth * 0.18, safeFeetPos.y - shoeHeight, shoeWidth, shoeHeight);
            ctx.fillRect(centerX + screenWidth * 0.06, safeFeetPos.y - shoeHeight, shoeWidth, shoeHeight);

            // === LEGS WITH WALKING ANIMATION ===
            // Legs show skin if clothing level <= 1 (naked or underwear)
            let legBaseColor;
            if (npc.clothingLevel <= 1) {
                legBaseColor = npc.skinTone;
            } else {
                legBaseColor = npc.color;
            }
            const legColor = darkenColor(legBaseColor, 30);
            // More realistic leg width - thinner and more proportional
            const legWidth = screenWidth * 0.14; // Was 0.16, now slimmer

            // Calculate hip position
            const hipYPos = safeWaistPos.y + (safeKneePos.y - safeWaistPos.y) * 0.15;

            // Walking animation offset - more natural stride
            const walkOffset = Math.sin((npc.walkCycle || 0)) * screenWidth * 0.10; // Slightly wider stride
            const leftLegX = centerX - screenWidth * 0.12 + walkOffset; // Legs closer together
            const rightLegX = centerX + screenWidth * 0.12 - walkOffset;

            // Left leg - full with animation
            const leftLegGrad = ctx.createLinearGradient(
                leftLegX - legWidth/2, hipYPos,
                leftLegX + legWidth/2, hipYPos
            );
            leftLegGrad.addColorStop(0, darkenColor(legColor, 30));
            leftLegGrad.addColorStop(0.5, legColor);
            leftLegGrad.addColorStop(1, darkenColor(legColor, 15));
            ctx.fillStyle = leftLegGrad;
            ctx.fillRect(leftLegX - legWidth/2, hipYPos, legWidth, safeFeetPos.y - hipYPos - shoeHeight);

            // Right leg - full with animation
            const rightLegGrad = ctx.createLinearGradient(
                rightLegX - legWidth/2, hipYPos,
                rightLegX + legWidth/2, hipYPos
            );
            rightLegGrad.addColorStop(0, darkenColor(legColor, 15));
            rightLegGrad.addColorStop(0.5, legColor);
            rightLegGrad.addColorStop(1, darkenColor(legColor, 30));
            ctx.fillStyle = rightLegGrad;
            ctx.fillRect(rightLegX - legWidth/2, hipYPos, legWidth, safeFeetPos.y - hipYPos - shoeHeight);

            // Knee joints for realism (follow animated legs)
            ctx.fillStyle = darkenColor(legColor, 20);
            ctx.beginPath();
            ctx.ellipse(leftLegX, safeKneePos.y, screenWidth * 0.09, screenHeight * 0.025, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(rightLegX, safeKneePos.y, screenWidth * 0.09, screenHeight * 0.025, 0, 0, Math.PI * 2);
            ctx.fill();

            // Hip/waist area (gender-specific)
            let hipWidth;
            if (npc.gender === 'female') {
                // FEMALE: Wider, curvier hips for hourglass figure
                hipWidth = screenWidth * 0.68;
            } else {
                // MALE: Narrower, athletic hips
                hipWidth = screenWidth * 0.6;
            }

            const hipGrad = ctx.createLinearGradient(
                centerX - hipWidth / 2, safeWaistPos.y,
                centerX + hipWidth / 2, safeWaistPos.y
            );
            hipGrad.addColorStop(0, darkenColor(legColor, 25));
            hipGrad.addColorStop(0.5, legColor);
            hipGrad.addColorStop(1, darkenColor(legColor, 25));
            ctx.fillStyle = hipGrad;

            const waistConnectionWidth = npc.gender === 'female' ? screenWidth * 0.35 : screenWidth * 0.38;
            ctx.beginPath();
            ctx.moveTo(centerX - waistConnectionWidth, safeWaistPos.y);
            ctx.lineTo(centerX + waistConnectionWidth, safeWaistPos.y);
            ctx.lineTo(centerX + hipWidth * 0.5, hipYPos);
            ctx.lineTo(centerX - hipWidth * 0.5, hipYPos);
            ctx.closePath();
            ctx.fill();

            // === TORSO (Gender-specific proportions) ===
            let shoulderWidth, waistWidth;
            if (npc.gender === 'female') {
                // FEMALE: More realistic hourglass figure - narrower shoulders, smaller waist
                shoulderWidth = screenWidth * 0.75; // Slightly wider for realism
                waistWidth = screenWidth * 0.50; // More defined waist
            } else {
                // MALE: More realistic V-shape - broader shoulders, defined waist
                shoulderWidth = screenWidth * 1.0; // Broader shoulders
                waistWidth = screenWidth * 0.72; // More defined V-taper
            }

            // Apply back arch effect for female NPCs during possession
            let archOffset = 0;
            if (npc.gender === 'female' && npc.backArch > 0) {
                archOffset = npc.backArch * screenWidth * 0.15; // Arch back effect
            }

            // Determine torso color based on clothing level
            let torsoBaseColor;
            if (npc.clothingLevel === 3) {
                // Fully clothed - use clothing color
                torsoBaseColor = npc.color;
            } else if (npc.clothingLevel === 2) {
                // Partially clothed - mix of skin and clothing
                torsoBaseColor = npc.color;
            } else if (npc.clothingLevel === 1) {
                // Underwear - show mostly skin with minimal coverage
                torsoBaseColor = npc.gender === 'male' ? darkenColor(npc.skinTone, 5) : lightenColor(npc.skinTone, 5);
            } else {
                // Naked - show skin tone
                torsoBaseColor = npc.skinTone;
            }

            const torsoGrad = ctx.createLinearGradient(
                centerX - shoulderWidth / 2, safeShoulderPos.y,
                centerX + shoulderWidth / 2, safeShoulderPos.y
            );
            torsoGrad.addColorStop(0, darkenColor(torsoBaseColor, 35));
            torsoGrad.addColorStop(0.25, darkenColor(torsoBaseColor, 15));
            torsoGrad.addColorStop(0.5, lightenColor(torsoBaseColor, 25));
            torsoGrad.addColorStop(0.75, torsoBaseColor);
            torsoGrad.addColorStop(1, darkenColor(torsoBaseColor, 35));
            ctx.fillStyle = torsoGrad;

            // Draw torso with arch effect
            ctx.beginPath();
            ctx.moveTo(centerX - shoulderWidth * 0.5, safeShoulderPos.y);
            ctx.lineTo(centerX + shoulderWidth * 0.5, safeShoulderPos.y);

            if (archOffset > 0) {
                // Curved back when arched
                const midY = (safeShoulderPos.y + safeWaistPos.y) / 2;
                ctx.quadraticCurveTo(centerX + waistWidth * 0.5 + archOffset, midY,
                                     centerX + waistWidth * 0.5, safeWaistPos.y);
                ctx.lineTo(centerX - waistWidth * 0.5, safeWaistPos.y);
                ctx.quadraticCurveTo(centerX - waistWidth * 0.5 - archOffset, midY,
                                     centerX - shoulderWidth * 0.5, safeShoulderPos.y);
            } else {
                // Normal torso
                ctx.lineTo(centerX + waistWidth * 0.5, safeWaistPos.y);
                ctx.lineTo(centerX - waistWidth * 0.5, safeWaistPos.y);
            }
            ctx.closePath();
            ctx.fill();

            // === DETAILED BODY ANATOMY (when naked or in underwear) ===
            if (npc.clothingLevel <= 1) {
                // Add muscle definition and body details
                ctx.globalAlpha = 0.15;

                if (npc.gender === 'male') {
                    // === ENHANCED MALE CHEST (PECS) WITH REALISTIC DEFINITION ===
                    const chestY = safeShoulderPos.y + (safeWaistPos.y - safeShoulderPos.y) * 0.26;
                    const pecWidth = shoulderWidth * 0.20;
                    const pecHeight = (safeWaistPos.y - safeShoulderPos.y) * 0.22;

                    // Safety check: ensure dimensions are positive
                    if (pecWidth <= 0 || pecHeight <= 0) {
                        ctx.globalAlpha = 1.0;
                        return; // Skip drawing if dimensions are invalid
                    }

                    // Pectoralis major (main chest muscle) with gradient for volume
                    const leftPecGrad = ctx.createRadialGradient(
                        centerX - shoulderWidth * 0.20, chestY - pecHeight * 0.15, Math.max(0.1, pecHeight * 0.2),
                        centerX - shoulderWidth * 0.18, chestY + pecHeight * 0.1, Math.max(1, pecWidth * 1.1)
                    );
                    leftPecGrad.addColorStop(0, lightenColor(npc.skinTone, 10));
                    leftPecGrad.addColorStop(0.35, darkenColor(npc.skinTone, 18));
                    leftPecGrad.addColorStop(0.65, darkenColor(npc.skinTone, 28));
                    leftPecGrad.addColorStop(1, darkenColor(npc.skinTone, 35));

                    ctx.globalAlpha = 0.75;
                    ctx.fillStyle = leftPecGrad;
                    ctx.beginPath();
                    ctx.ellipse(centerX - shoulderWidth * 0.18, chestY, pecWidth * 0.95, pecHeight * 0.95, -0.15, 0, Math.PI * 2);
                    ctx.fill();

                    const rightPecGrad = ctx.createRadialGradient(
                        centerX + shoulderWidth * 0.20, chestY - pecHeight * 0.15, Math.max(0.1, pecHeight * 0.2),
                        centerX + shoulderWidth * 0.18, chestY + pecHeight * 0.1, Math.max(1, pecWidth * 1.1)
                    );
                    rightPecGrad.addColorStop(0, lightenColor(npc.skinTone, 10));
                    rightPecGrad.addColorStop(0.35, darkenColor(npc.skinTone, 18));
                    rightPecGrad.addColorStop(0.65, darkenColor(npc.skinTone, 28));
                    rightPecGrad.addColorStop(1, darkenColor(npc.skinTone, 35));

                    ctx.fillStyle = rightPecGrad;
                    ctx.beginPath();
                    ctx.ellipse(centerX + shoulderWidth * 0.18, chestY, pecWidth * 0.95, pecHeight * 0.95, 0.15, 0, Math.PI * 2);
                    ctx.fill();

                    // Pec separation (sternum cleft)
                    ctx.globalAlpha = 0.35;
                    ctx.fillStyle = darkenColor(npc.skinTone, 40);
                    ctx.fillRect(centerX - screenWidth * 0.018, chestY - pecHeight * 0.6,
                                screenWidth * 0.036, pecHeight * 1.3);

                    // Lower pec definition (underpec shadow)
                    ctx.globalAlpha = 0.28;
                    ctx.beginPath();
                    ctx.ellipse(centerX - shoulderWidth * 0.18, chestY + pecHeight * 0.72, pecWidth * 0.75, pecHeight * 0.22, 0, 0, Math.PI);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(centerX + shoulderWidth * 0.18, chestY + pecHeight * 0.72, pecWidth * 0.75, pecHeight * 0.22, 0, 0, Math.PI);
                    ctx.fill();

                    // === ENHANCED ABS (SIX-PACK) ===
                    const absStartY = chestY + pecHeight * 1.05;
                    const absSpacing = (safeWaistPos.y - absStartY) / 3.8;
                    const absWidth = waistWidth * 0.16;
                    const absHeight = absSpacing * 0.68;

                    for (let i = 0; i < 3; i++) {
                        const absY = absStartY + i * absSpacing * 0.95;

                        // Left abs with gradient
                        const leftAbsGrad = ctx.createRadialGradient(
                            centerX - waistWidth * 0.13, absY - absHeight * 0.2, Math.max(0.1, absHeight * 0.1),
                            centerX - waistWidth * 0.12, absY, Math.max(1, absWidth * 0.9)
                        );
                        leftAbsGrad.addColorStop(0, lightenColor(npc.skinTone, 5));
                        leftAbsGrad.addColorStop(0.4, darkenColor(npc.skinTone, 22));
                        leftAbsGrad.addColorStop(1, darkenColor(npc.skinTone, 32));

                        ctx.globalAlpha = 0.7;
                        ctx.fillStyle = leftAbsGrad;
                        ctx.beginPath();
                        ctx.ellipse(centerX - waistWidth * 0.12, absY, absWidth * 0.85, absHeight, 0, 0, Math.PI * 2);
                        ctx.fill();

                        // Right abs with gradient
                        const rightAbsGrad = ctx.createRadialGradient(
                            centerX + waistWidth * 0.13, absY - absHeight * 0.2, Math.max(0.1, absHeight * 0.1),
                            centerX + waistWidth * 0.12, absY, Math.max(1, absWidth * 0.9)
                        );
                        rightAbsGrad.addColorStop(0, lightenColor(npc.skinTone, 5));
                        rightAbsGrad.addColorStop(0.4, darkenColor(npc.skinTone, 22));
                        rightAbsGrad.addColorStop(1, darkenColor(npc.skinTone, 32));

                        ctx.fillStyle = rightAbsGrad;
                        ctx.beginPath();
                        ctx.ellipse(centerX + waistWidth * 0.12, absY, absWidth * 0.85, absHeight, 0, 0, Math.PI * 2);
                        ctx.fill();

                        // Ab separation shadows
                        ctx.globalAlpha = 0.25;
                        ctx.fillStyle = darkenColor(npc.skinTone, 38);
                        ctx.fillRect(centerX - waistWidth * 0.03, absY - absHeight * 0.3,
                                    waistWidth * 0.06, absHeight * 0.4);
                    }

                    // Linea alba (centerline of abs)
                    ctx.globalAlpha = 0.18;
                    ctx.fillStyle = darkenColor(npc.skinTone, 30);
                    ctx.fillRect(centerX - screenWidth * 0.012, absStartY - absSpacing * 0.2,
                                screenWidth * 0.024, 3 * absSpacing * 0.95);

                    // Obliques (side abs)
                    ctx.globalAlpha = 0.15;
                    for (let i = 0; i < 2; i++) {
                        const obliqueY = absStartY + absSpacing * (i + 1);
                        // Left obliques
                        ctx.beginPath();
                        ctx.ellipse(centerX - waistWidth * 0.28, obliqueY, waistWidth * 0.08, absSpacing * 0.4, -0.4, 0, Math.PI * 2);
                        ctx.fill();
                        // Right obliques
                        ctx.beginPath();
                        ctx.ellipse(centerX + waistWidth * 0.28, obliqueY, waistWidth * 0.08, absSpacing * 0.4, 0.4, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // === DETAILED MALE NIPPLES ===
                    ctx.globalAlpha = 0.45;
                    ctx.fillStyle = darkenColor(npc.skinTone, 38);
                    const nippleSize = screenWidth * 0.022;

                    // Left nipple
                    ctx.beginPath();
                    ctx.arc(centerX - shoulderWidth * 0.18, chestY + pecHeight * 0.08, nippleSize, 0, Math.PI * 2);
                    ctx.fill();

                    // Right nipple
                    ctx.beginPath();
                    ctx.arc(centerX + shoulderWidth * 0.18, chestY + pecHeight * 0.08, nippleSize, 0, Math.PI * 2);
                    ctx.fill();

                    // Nipple highlights
                    ctx.globalAlpha = 0.25;
                    ctx.fillStyle = lightenColor(darkenColor(npc.skinTone, 35), 8);
                    ctx.beginPath();
                    ctx.arc(centerX - shoulderWidth * 0.18 - nippleSize * 0.3, chestY + pecHeight * 0.08 - nippleSize * 0.3,
                           nippleSize * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(centerX + shoulderWidth * 0.18 + nippleSize * 0.3, chestY + pecHeight * 0.08 - nippleSize * 0.3,
                           nippleSize * 0.4, 0, Math.PI * 2);
                    ctx.fill();

                } else {
                    // Female chest (breasts) - ENHANCED REALISTIC VERSION
                    const breastY = safeShoulderPos.y + (safeWaistPos.y - safeShoulderPos.y) * 0.28;
                    const breastSize = shoulderWidth * 0.28;
                    const breastSpacing = shoulderWidth * 0.24;

                    // === REALISTIC BREAST RENDERING ===

                    // Safety check for breast dimensions
                    if (breastSize <= 0 || breastSpacing <= 0) {
                        ctx.globalAlpha = 1.0;
                        return; // Skip drawing if dimensions are invalid
                    }

                    // Main breast volume with radial gradient for 3D sphere effect
                    const leftBreastGrad = ctx.createRadialGradient(
                        centerX - breastSpacing - breastSize * 0.25, breastY - breastSize * 0.2, Math.max(0.1, breastSize * 0.1),
                        centerX - breastSpacing, breastY, Math.max(1, breastSize * 0.95)
                    );
                    leftBreastGrad.addColorStop(0, lightenColor(npc.skinTone, 18));
                    leftBreastGrad.addColorStop(0.4, npc.skinTone);
                    leftBreastGrad.addColorStop(0.7, darkenColor(npc.skinTone, 12));
                    leftBreastGrad.addColorStop(1, darkenColor(npc.skinTone, 25));

                    ctx.globalAlpha = 0.85;
                    ctx.fillStyle = leftBreastGrad;
                    ctx.beginPath();
                    ctx.ellipse(centerX - breastSpacing, breastY, breastSize * 0.88, breastSize * 1.15, -0.08, 0, Math.PI * 2);
                    ctx.fill();

                    const rightBreastGrad = ctx.createRadialGradient(
                        centerX + breastSpacing + breastSize * 0.25, breastY - breastSize * 0.2, Math.max(0.1, breastSize * 0.1),
                        centerX + breastSpacing, breastY, Math.max(1, breastSize * 0.95)
                    );
                    rightBreastGrad.addColorStop(0, lightenColor(npc.skinTone, 18));
                    rightBreastGrad.addColorStop(0.4, npc.skinTone);
                    rightBreastGrad.addColorStop(0.7, darkenColor(npc.skinTone, 12));
                    rightBreastGrad.addColorStop(1, darkenColor(npc.skinTone, 25));

                    ctx.fillStyle = rightBreastGrad;
                    ctx.beginPath();
                    ctx.ellipse(centerX + breastSpacing, breastY, breastSize * 0.88, breastSize * 1.15, 0.08, 0, Math.PI * 2);
                    ctx.fill();

                    // Underboob curve and shadow (deep crease)
                    ctx.globalAlpha = 0.35;
                    ctx.fillStyle = darkenColor(npc.skinTone, 40);
                    ctx.beginPath();
                    ctx.ellipse(centerX - breastSpacing, breastY + breastSize * 0.78, breastSize * 0.72, breastSize * 0.28, 0, 0, Math.PI);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(centerX + breastSpacing, breastY + breastSize * 0.78, breastSize * 0.72, breastSize * 0.28, 0, 0, Math.PI);
                    ctx.fill();

                    // Inner breast shadow (cleavage)
                    ctx.globalAlpha = 0.28;
                    ctx.fillStyle = darkenColor(npc.skinTone, 35);
                    ctx.beginPath();
                    ctx.ellipse(centerX - breastSpacing * 0.35, breastY + breastSize * 0.15, breastSize * 0.3, breastSize * 0.8, 0.15, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(centerX + breastSpacing * 0.35, breastY + breastSize * 0.15, breastSize * 0.3, breastSize * 0.8, -0.15, 0, Math.PI * 2);
                    ctx.fill();

                    // Top highlight for volume
                    ctx.globalAlpha = 0.22;
                    ctx.fillStyle = lightenColor(npc.skinTone, 30);
                    ctx.beginPath();
                    ctx.ellipse(centerX - breastSpacing - breastSize * 0.15, breastY - breastSize * 0.35, breastSize * 0.4, breastSize * 0.35, -0.2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(centerX + breastSpacing + breastSize * 0.15, breastY - breastSize * 0.35, breastSize * 0.4, breastSize * 0.35, 0.2, 0, Math.PI * 2);
                    ctx.fill();

                    if (npc.clothingLevel === 0) {
                        // === DETAILED NIPPLES AND AREOLA (only when fully naked) ===
                        const nippleSize = screenWidth * 0.035;
                        const areolaSize = screenWidth * 0.065;

                        // Areola (darker circle around nipple)
                        ctx.globalAlpha = 0.5;
                        ctx.fillStyle = darkenColor(npc.skinTone, 45);
                        ctx.beginPath();
                        ctx.arc(centerX - breastSpacing, breastY - breastSize * 0.22, areolaSize, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(centerX + breastSpacing, breastY - breastSize * 0.22, areolaSize, 0, Math.PI * 2);
                        ctx.fill();

                        // Areola texture (bumpy texture)
                        ctx.globalAlpha = 0.25;
                        for (let i = 0; i < 8; i++) {
                            const angle = (Math.PI * 2 * i) / 8;
                            const bumpDist = areolaSize * 0.6;
                            ctx.beginPath();
                            ctx.arc(centerX - breastSpacing + Math.cos(angle) * bumpDist,
                                   breastY - breastSize * 0.22 + Math.sin(angle) * bumpDist,
                                   screenWidth * 0.008, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.beginPath();
                            ctx.arc(centerX + breastSpacing + Math.cos(angle) * bumpDist,
                                   breastY - breastSize * 0.22 + Math.sin(angle) * bumpDist,
                                   screenWidth * 0.008, 0, Math.PI * 2);
                            ctx.fill();
                        }

                        // Nipple with gradient (protruding effect)
                        const nippleGradL = ctx.createRadialGradient(
                            centerX - breastSpacing - nippleSize * 0.3, breastY - breastSize * 0.22 - nippleSize * 0.2, Math.max(0.1, nippleSize * 0.1),
                            centerX - breastSpacing, breastY - breastSize * 0.22, Math.max(1, nippleSize)
                        );
                        nippleGradL.addColorStop(0, lightenColor(darkenColor(npc.skinTone, 42), 10));
                        nippleGradL.addColorStop(0.6, darkenColor(npc.skinTone, 48));
                        nippleGradL.addColorStop(1, darkenColor(npc.skinTone, 55));

                        ctx.globalAlpha = 0.8;
                        ctx.fillStyle = nippleGradL;
                        ctx.beginPath();
                        ctx.arc(centerX - breastSpacing, breastY - breastSize * 0.22, nippleSize, 0, Math.PI * 2);
                        ctx.fill();

                        const nippleGradR = ctx.createRadialGradient(
                            centerX + breastSpacing + nippleSize * 0.3, breastY - breastSize * 0.22 - nippleSize * 0.2, Math.max(0.1, nippleSize * 0.1),
                            centerX + breastSpacing, breastY - breastSize * 0.22, Math.max(1, nippleSize)
                        );
                        nippleGradR.addColorStop(0, lightenColor(darkenColor(npc.skinTone, 42), 10));
                        nippleGradR.addColorStop(0.6, darkenColor(npc.skinTone, 48));
                        nippleGradR.addColorStop(1, darkenColor(npc.skinTone, 55));

                        ctx.fillStyle = nippleGradR;
                        ctx.beginPath();
                        ctx.arc(centerX + breastSpacing, breastY - breastSize * 0.22, nippleSize, 0, Math.PI * 2);
                        ctx.fill();

                        // Nipple highlight (tip)
                        ctx.globalAlpha = 0.4;
                        ctx.fillStyle = lightenColor(darkenColor(npc.skinTone, 40), 15);
                        ctx.beginPath();
                        ctx.arc(centerX - breastSpacing - nippleSize * 0.25, breastY - breastSize * 0.22 - nippleSize * 0.25, nippleSize * 0.35, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(centerX + breastSpacing + nippleSize * 0.25, breastY - breastSize * 0.22 - nippleSize * 0.25, nippleSize * 0.35, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Enhanced abs/core definition for athletic females
                    ctx.globalAlpha = 0.12;
                    ctx.fillStyle = darkenColor(npc.skinTone, 20);
                    const femaleAbsY = breastY + breastSize * 1.3;
                    const absCount = 3;
                    const absSpacing = (safeWaistPos.y - femaleAbsY) / (absCount + 0.5);

                    for (let i = 0; i < absCount; i++) {
                        const y = femaleAbsY + i * absSpacing * 0.85;
                        // Left abs
                        ctx.beginPath();
                        ctx.ellipse(centerX - waistWidth * 0.11, y, waistWidth * 0.13, absSpacing * 0.32, 0, 0, Math.PI * 2);
                        ctx.fill();
                        // Right abs
                        ctx.beginPath();
                        ctx.ellipse(centerX + waistWidth * 0.11, y, waistWidth * 0.13, absSpacing * 0.32, 0, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Ab line (linea alba)
                    ctx.globalAlpha = 0.08;
                    ctx.fillStyle = darkenColor(npc.skinTone, 25);
                    ctx.fillRect(centerX - screenWidth * 0.01, femaleAbsY - absSpacing * 0.3,
                                screenWidth * 0.02, (absCount - 0.5) * absSpacing * 0.85);
                }

                // Enhanced navel (belly button) for both genders
                ctx.globalAlpha = 0.5;
                ctx.fillStyle = darkenColor(npc.skinTone, 48);
                const navelY = safeWaistPos.y - (safeWaistPos.y - safeShoulderPos.y) * 0.15;
                ctx.beginPath();
                ctx.ellipse(centerX, navelY, screenWidth * 0.022, screenWidth * 0.038, 0, 0, Math.PI * 2);
                ctx.fill();

                // Navel shadow/depth
                ctx.globalAlpha = 0.3;
                ctx.fillStyle = darkenColor(npc.skinTone, 55);
                ctx.beginPath();
                ctx.ellipse(centerX, navelY + screenWidth * 0.012, screenWidth * 0.015, screenWidth * 0.025, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.globalAlpha = 1.0; // Reset alpha
            }

            // === GENITAL AREA ANATOMY (when clothingLevel === 0, fully naked) ===
            if (npc.clothingLevel === 0) {
                const genitalY = safeWaistPos.y + (safeWaistPos.y - safeShoulderPos.y) * 0.08;

                if (npc.gender === 'male') {
                    // === MALE GENITALIA (realistic but tasteful) ===
                    const penisWidth = screenWidth * 0.08;
                    const penisLength = (safeWaistPos.y - safeShoulderPos.y) * 0.18;

                    // Penis shaft with gradient for cylindrical form
                    const penisGrad = ctx.createLinearGradient(
                        centerX - penisWidth * 0.4, genitalY,
                        centerX + penisWidth * 0.4, genitalY
                    );
                    penisGrad.addColorStop(0, darkenColor(npc.skinTone, 25));
                    penisGrad.addColorStop(0.3, lightenColor(npc.skinTone, 8));
                    penisGrad.addColorStop(0.7, npc.skinTone);
                    penisGrad.addColorStop(1, darkenColor(npc.skinTone, 20));

                    ctx.globalAlpha = 0.9;
                    ctx.fillStyle = penisGrad;
                    ctx.fillRect(centerX - penisWidth * 0.35, genitalY, penisWidth * 0.7, penisLength);

                    // Penis head (glans) with rounded end
                    const glansGrad = ctx.createRadialGradient(
                        centerX, genitalY + penisLength - penisWidth * 0.25, Math.max(0.1, penisWidth * 0.1),
                        centerX, genitalY + penisLength, Math.max(1, penisWidth * 0.45)
                    );
                    glansGrad.addColorStop(0, lightenColor(npc.skinTone, 12));
                    glansGrad.addColorStop(0.5, darkenColor(npc.skinTone, 5));
                    glansGrad.addColorStop(1, darkenColor(npc.skinTone, 22));

                    ctx.fillStyle = glansGrad;
                    ctx.beginPath();
                    ctx.ellipse(centerX, genitalY + penisLength, penisWidth * 0.42, penisWidth * 0.5, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Glans corona (ridge)
                    ctx.globalAlpha = 0.35;
                    ctx.fillStyle = darkenColor(npc.skinTone, 28);
                    ctx.beginPath();
                    ctx.ellipse(centerX, genitalY + penisLength - penisWidth * 0.15, penisWidth * 0.4, penisWidth * 0.12, 0, 0, Math.PI);
                    ctx.fill();

                    // Testicles with realistic shading
                    const testicleSize = screenWidth * 0.055;
                    const testicleY = genitalY + penisLength * 0.4;

                    // Left testicle
                    const leftTesticleGrad = ctx.createRadialGradient(
                        centerX - penisWidth * 0.25 - testicleSize * 0.2, testicleY - testicleSize * 0.15, Math.max(0.1, testicleSize * 0.2),
                        centerX - penisWidth * 0.25, testicleY, Math.max(1, testicleSize * 0.9)
                    );
                    leftTesticleGrad.addColorStop(0, lightenColor(npc.skinTone, 5));
                    leftTesticleGrad.addColorStop(0.5, darkenColor(npc.skinTone, 15));
                    leftTesticleGrad.addColorStop(1, darkenColor(npc.skinTone, 30));

                    ctx.globalAlpha = 0.85;
                    ctx.fillStyle = leftTesticleGrad;
                    ctx.beginPath();
                    ctx.ellipse(centerX - penisWidth * 0.25, testicleY, testicleSize * 0.75, testicleSize * 0.95, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Right testicle (slightly lower for realism)
                    const rightTesticleGrad = ctx.createRadialGradient(
                        centerX + penisWidth * 0.25 + testicleSize * 0.2, testicleY + testicleSize * 0.1 - testicleSize * 0.15, Math.max(0.1, testicleSize * 0.2),
                        centerX + penisWidth * 0.25, testicleY + testicleSize * 0.1, Math.max(1, testicleSize * 0.9)
                    );
                    rightTesticleGrad.addColorStop(0, lightenColor(npc.skinTone, 5));
                    rightTesticleGrad.addColorStop(0.5, darkenColor(npc.skinTone, 15));
                    rightTesticleGrad.addColorStop(1, darkenColor(npc.skinTone, 30));

                    ctx.fillStyle = rightTesticleGrad;
                    ctx.beginPath();
                    ctx.ellipse(centerX + penisWidth * 0.25, testicleY + testicleSize * 0.1, testicleSize * 0.75, testicleSize * 0.95, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Scrotum seam (raphe)
                    ctx.globalAlpha = 0.25;
                    ctx.fillStyle = darkenColor(npc.skinTone, 40);
                    ctx.fillRect(centerX - screenWidth * 0.006, testicleY - testicleSize * 0.5,
                                screenWidth * 0.012, testicleSize * 1.5);

                } else {
                    // === FEMALE GENITALIA (realistic but tasteful) ===
                    const vulvaWidth = screenWidth * 0.11;
                    const vulvaHeight = (safeWaistPos.y - safeShoulderPos.y) * 0.16;

                    // Mons pubis (mound) with gradient
                    const monsGrad = ctx.createRadialGradient(
                        centerX, genitalY - vulvaHeight * 0.1, Math.max(0.1, vulvaWidth * 0.2),
                        centerX, genitalY + vulvaHeight * 0.2, Math.max(1, vulvaWidth * 0.55)
                    );
                    monsGrad.addColorStop(0, lightenColor(npc.skinTone, 8));
                    monsGrad.addColorStop(0.5, npc.skinTone);
                    monsGrad.addColorStop(1, darkenColor(npc.skinTone, 18));

                    ctx.globalAlpha = 0.9;
                    ctx.fillStyle = monsGrad;
                    ctx.beginPath();
                    ctx.ellipse(centerX, genitalY + vulvaHeight * 0.15, vulvaWidth * 0.48, vulvaHeight * 0.55, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Vulva cleft (vestibule) - central shadow
                    ctx.globalAlpha = 0.45;
                    ctx.fillStyle = darkenColor(npc.skinTone, 50);
                    ctx.fillRect(centerX - screenWidth * 0.008, genitalY + vulvaHeight * 0.05,
                                screenWidth * 0.016, vulvaHeight * 0.7);

                    // Labia majora (outer lips) with volume
                    const labiaOuterGradL = ctx.createRadialGradient(
                        centerX - vulvaWidth * 0.18, genitalY + vulvaHeight * 0.35, Math.max(0.1, vulvaWidth * 0.08),
                        centerX - vulvaWidth * 0.15, genitalY + vulvaHeight * 0.4, Math.max(1, vulvaWidth * 0.2)
                    );
                    labiaOuterGradL.addColorStop(0, lightenColor(npc.skinTone, 5));
                    labiaOuterGradL.addColorStop(0.5, npc.skinTone);
                    labiaOuterGradL.addColorStop(1, darkenColor(npc.skinTone, 25));

                    ctx.globalAlpha = 0.85;
                    ctx.fillStyle = labiaOuterGradL;
                    ctx.beginPath();
                    ctx.ellipse(centerX - vulvaWidth * 0.15, genitalY + vulvaHeight * 0.4, vulvaWidth * 0.16, vulvaHeight * 0.58, 0, 0, Math.PI * 2);
                    ctx.fill();

                    const labiaOuterGradR = ctx.createRadialGradient(
                        centerX + vulvaWidth * 0.18, genitalY + vulvaHeight * 0.35, Math.max(0.1, vulvaWidth * 0.08),
                        centerX + vulvaWidth * 0.15, genitalY + vulvaHeight * 0.4, Math.max(1, vulvaWidth * 0.2)
                    );
                    labiaOuterGradR.addColorStop(0, lightenColor(npc.skinTone, 5));
                    labiaOuterGradR.addColorStop(0.5, npc.skinTone);
                    labiaOuterGradR.addColorStop(1, darkenColor(npc.skinTone, 25));

                    ctx.fillStyle = labiaOuterGradR;
                    ctx.beginPath();
                    ctx.ellipse(centerX + vulvaWidth * 0.15, genitalY + vulvaHeight * 0.4, vulvaWidth * 0.16, vulvaHeight * 0.58, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Labia minora (inner lips) - darker, more delicate
                    ctx.globalAlpha = 0.55;
                    ctx.fillStyle = darkenColor(npc.skinTone, 35);
                    ctx.beginPath();
                    ctx.ellipse(centerX - vulvaWidth * 0.06, genitalY + vulvaHeight * 0.42, vulvaWidth * 0.055, vulvaHeight * 0.48, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(centerX + vulvaWidth * 0.06, genitalY + vulvaHeight * 0.42, vulvaWidth * 0.055, vulvaHeight * 0.48, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Clitoral hood (subtle indication at top)
                    ctx.globalAlpha = 0.4;
                    ctx.fillStyle = darkenColor(npc.skinTone, 40);
                    ctx.beginPath();
                    ctx.ellipse(centerX, genitalY + vulvaHeight * 0.12, vulvaWidth * 0.045, vulvaHeight * 0.08, 0, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.globalAlpha = 1.0; // Reset alpha
            }

            // === UNDERWEAR COVERAGE (when clothingLevel === 1) ===
            if (npc.clothingLevel === 1) {
                // Draw minimal underwear
                const underwearColor = npc.gender === 'female' ? '#FFB6C1' : '#4169E1';

                // Bottom underwear (briefs/panties)
                ctx.fillStyle = underwearColor;
                ctx.globalAlpha = 0.7;
                const underwearWidth = waistWidth * 0.7;
                const underwearHeight = (safeWaistPos.y - safeShoulderPos.y) * 0.2;
                ctx.fillRect(centerX - underwearWidth * 0.5, safeWaistPos.y - underwearHeight * 0.3,
                           underwearWidth, underwearHeight);

                if (npc.gender === 'female') {
                    // Sports bra/bra top
                    const braY = safeShoulderPos.y + (safeWaistPos.y - safeShoulderPos.y) * 0.2;
                    const braHeight = (safeWaistPos.y - safeShoulderPos.y) * 0.25;
                    ctx.fillRect(centerX - shoulderWidth * 0.35, braY, shoulderWidth * 0.7, braHeight);
                }

                ctx.globalAlpha = 1.0; // Reset alpha
            }

            // === ARMS (Enhanced with gradients and muscle definition) ===
            const armWidth = screenWidth * 0.12;
            const armLength = safeWaistPos.y - safeShoulderPos.y;
            const torsoWidth = screenWidth;

            // Arms show skin if clothing level < 3
            const armColor = npc.clothingLevel < 3 ? npc.skinTone : darkenColor(npc.color, 20);

            // Left arm with rotation animation
            ctx.save();
            const leftShoulderX = centerX - torsoWidth * 0.6 + armWidth * 0.5;
            const leftShoulderY = safeShoulderPos.y;
            ctx.translate(leftShoulderX, leftShoulderY);
            ctx.rotate(-npc.leftArmAngle); // Negative for upward rotation
            ctx.translate(-leftShoulderX, -leftShoulderY);

            const leftArmGrad = ctx.createLinearGradient(
                centerX - torsoWidth * 0.6, safeShoulderPos.y,
                centerX - torsoWidth * 0.6 + armWidth, safeShoulderPos.y
            );
            leftArmGrad.addColorStop(0, darkenColor(armColor, 30));
            leftArmGrad.addColorStop(0.3, armColor);
            leftArmGrad.addColorStop(0.7, lightenColor(armColor, 15));
            leftArmGrad.addColorStop(1, armColor);
            ctx.fillStyle = leftArmGrad;
            ctx.fillRect(centerX - torsoWidth * 0.6, safeShoulderPos.y, armWidth, armLength * 0.7);
            ctx.restore();

            // Right arm with rotation animation
            ctx.save();
            const rightShoulderX = centerX + torsoWidth * 0.48 + armWidth * 0.5;
            const rightShoulderY = safeShoulderPos.y;
            ctx.translate(rightShoulderX, rightShoulderY);
            ctx.rotate(-npc.rightArmAngle); // Negative for upward rotation
            ctx.translate(-rightShoulderX, -rightShoulderY);

            const rightArmGrad = ctx.createLinearGradient(
                centerX + torsoWidth * 0.48, safeShoulderPos.y,
                centerX + torsoWidth * 0.48 + armWidth, safeShoulderPos.y
            );
            rightArmGrad.addColorStop(0, armColor);
            rightArmGrad.addColorStop(0.3, lightenColor(armColor, 15));
            rightArmGrad.addColorStop(0.7, armColor);
            rightArmGrad.addColorStop(1, darkenColor(armColor, 30));
            ctx.fillStyle = rightArmGrad;
            ctx.fillRect(centerX + torsoWidth * 0.48, safeShoulderPos.y, armWidth, armLength * 0.7);
            ctx.restore();

            // Bicep/shoulder muscle definition (when skin showing)
            if (npc.clothingLevel < 3) {
                ctx.globalAlpha = 0.15;
                ctx.fillStyle = darkenColor(npc.skinTone, 25);

                // Left shoulder/bicep
                ctx.beginPath();
                ctx.ellipse(centerX - torsoWidth * 0.54, safeShoulderPos.y + armLength * 0.25,
                           armWidth * 0.4, armWidth * 0.5, 0, 0, Math.PI * 2);
                ctx.fill();

                // Right shoulder/bicep
                ctx.beginPath();
                ctx.ellipse(centerX + torsoWidth * 0.54, safeShoulderPos.y + armLength * 0.25,
                           armWidth * 0.4, armWidth * 0.5, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.globalAlpha = 1.0;
            }

            // Hands with better detail
            const handGradLeft = ctx.createRadialGradient(
                centerX - torsoWidth * 0.54 - armWidth * 0.15, safeShoulderPos.y + armLength * 0.9 - armWidth * 0.2,
                Math.max(0.1, armWidth * 0.1),
                centerX - torsoWidth * 0.54, safeShoulderPos.y + armLength * 0.9,
                Math.max(1, armWidth * 0.7)
            );
            handGradLeft.addColorStop(0, lightenColor(npc.skinTone, 20));
            handGradLeft.addColorStop(0.6, npc.skinTone);
            handGradLeft.addColorStop(1, darkenColor(npc.skinTone, 20));
            ctx.fillStyle = handGradLeft;
            ctx.beginPath();
            ctx.ellipse(centerX - torsoWidth * 0.54, safeShoulderPos.y + armLength * 0.9,
                       armWidth * 0.5, armWidth * 0.7, 0, 0, Math.PI * 2);
            ctx.fill();

            // Right hand with gradient
            const handGradRight = ctx.createRadialGradient(
                centerX + torsoWidth * 0.54 + armWidth * 0.15, safeShoulderPos.y + armLength * 0.9 - armWidth * 0.2,
                Math.max(0.1, armWidth * 0.1),
                centerX + torsoWidth * 0.54, safeShoulderPos.y + armLength * 0.9,
                Math.max(1, armWidth * 0.7)
            );
            handGradRight.addColorStop(0, lightenColor(npc.skinTone, 20));
            handGradRight.addColorStop(0.6, npc.skinTone);
            handGradRight.addColorStop(1, darkenColor(npc.skinTone, 20));
            ctx.fillStyle = handGradRight;
            ctx.beginPath();
            ctx.ellipse(centerX + torsoWidth * 0.54, safeShoulderPos.y + armLength * 0.9,
                       armWidth * 0.5, armWidth * 0.7, 0, 0, Math.PI * 2);
            ctx.fill();

            // === NECK (Enhanced with gradient) ===
            const neckWidth = screenWidth * 0.18;
            const neckHeight = safeNeckPos.y - safeShoulderPos.y;

            const neckGrad = ctx.createLinearGradient(
                centerX - neckWidth / 2, safeShoulderPos.y,
                centerX + neckWidth / 2, safeShoulderPos.y
            );
            neckGrad.addColorStop(0, darkenColor(npc.skinTone, 15));
            neckGrad.addColorStop(0.5, npc.skinTone);
            neckGrad.addColorStop(1, darkenColor(npc.skinTone, 15));
            ctx.fillStyle = neckGrad;
            ctx.fillRect(centerX - neckWidth / 2, safeShoulderPos.y, neckWidth, neckHeight);

            // Subtle throat shadow for depth
            ctx.globalAlpha = 0.1;
            ctx.fillStyle = darkenColor(npc.skinTone, 30);
            ctx.fillRect(centerX - neckWidth * 0.3, safeShoulderPos.y + neckHeight * 0.3,
                        neckWidth * 0.6, neckHeight * 0.4);
            ctx.globalAlpha = 1.0;

            // === HEAD ===
            const headWidth = screenWidth * 0.5;
            const headHeight = screenHeight * 0.16;
            const headCenterY = safeHeadTopPos.y + headHeight * 0.6;

            const headGradient = ctx.createRadialGradient(
                centerX - headWidth * 0.15, headCenterY - headHeight * 0.1, Math.max(0.1, headWidth * 0.05),
                centerX, headCenterY, Math.max(1, headWidth * 0.55)
            );
            headGradient.addColorStop(0, lightenColor(npc.skinTone, 40));
            headGradient.addColorStop(0.5, npc.skinTone);
            headGradient.addColorStop(1, darkenColor(npc.skinTone, 25));
            ctx.fillStyle = headGradient;
            ctx.beginPath();
            ctx.ellipse(centerX, headCenterY, headWidth * 0.48, headHeight * 0.55, 0, 0, Math.PI * 2);
            ctx.fill();

            // Ears
            ctx.fillStyle = darkenColor(npc.skinTone, 10);
            ctx.beginPath();
            ctx.ellipse(centerX - headWidth * 0.48, headCenterY, headWidth * 0.08, headHeight * 0.15, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(centerX + headWidth * 0.48, headCenterY, headWidth * 0.08, headHeight * 0.15, 0, 0, Math.PI * 2);
            ctx.fill();

            // Hair cap on top of head (long hair already drawn behind body)
            ctx.fillStyle = npc.hairColor;
            ctx.beginPath();
            ctx.ellipse(centerX, safeHeadTopPos.y + headHeight * 0.25,
                       headWidth * 0.5, headHeight * 0.35, 0, Math.PI, 0);
            ctx.fill();

            // === FACIAL FEATURES (BEAUTIFUL/HANDSOME) ===
            const eyeY = headCenterY - headHeight * 0.02; // Slightly higher eyes
            const eyeSpacing = headWidth * (npc.gender === 'female' ? 0.16 : 0.15);

            // Check if eyes should be closed (dead NPCs)
            if (npc.eyesClosed) {
                // Draw closed eyes (just eyelids)
                ctx.strokeStyle = darkenColor(npc.hairColor || '#000', 30);
                ctx.lineWidth = Math.max(2, screenHeight * 0.01);
                ctx.lineCap = 'round';

                // Left eye (closed)
                ctx.beginPath();
                ctx.arc(centerX - eyeSpacing, eyeY, headWidth * 0.08, 0.2, Math.PI - 0.2);
                ctx.stroke();

                // Right eye (closed)
                ctx.beginPath();
                ctx.arc(centerX + eyeSpacing, eyeY, headWidth * 0.08, 0.2, Math.PI - 0.2);
                ctx.stroke();

                // Still draw eyebrows
                if (npc.gender === 'female') {
                    ctx.strokeStyle = darkenColor(npc.hairColor, 10);
                    ctx.lineWidth = Math.max(2, screenHeight * 0.01);
                    ctx.beginPath();
                    ctx.moveTo(centerX - eyeSpacing - headWidth * 0.12, eyeY - headHeight * 0.18);
                    ctx.quadraticCurveTo(centerX - eyeSpacing, eyeY - headHeight * 0.22,
                                        centerX - eyeSpacing + headWidth * 0.08, eyeY - headHeight * 0.19);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(centerX + eyeSpacing + headWidth * 0.12, eyeY - headHeight * 0.18);
                    ctx.quadraticCurveTo(centerX + eyeSpacing, eyeY - headHeight * 0.22,
                                        centerX + eyeSpacing - headWidth * 0.08, eyeY - headHeight * 0.19);
                    ctx.stroke();
                } else {
                    ctx.strokeStyle = darkenColor(npc.hairColor, 5);
                    ctx.lineWidth = Math.max(2.5, screenHeight * 0.013);
                    ctx.beginPath();
                    ctx.moveTo(centerX - eyeSpacing - headWidth * 0.11, eyeY - headHeight * 0.16);
                    ctx.lineTo(centerX - eyeSpacing + headWidth * 0.06, eyeY - headHeight * 0.19);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(centerX + eyeSpacing + headWidth * 0.11, eyeY - headHeight * 0.16);
                    ctx.lineTo(centerX + eyeSpacing - headWidth * 0.06, eyeY - headHeight * 0.19);
                    ctx.stroke();
                }
            } else if (npc.possessed) {
                // Glowing possessed eyes
                ctx.fillStyle = '#8a2be2';
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#8a2be2';
                ctx.beginPath();
                ctx.ellipse(centerX - eyeSpacing, eyeY, headWidth * 0.08, headHeight * 0.12, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(centerX + eyeSpacing, eyeY, headWidth * 0.08, headHeight * 0.12, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            } else {
                // Gender-specific attractive eyes
                if (npc.gender === 'female') {
                    // FEMALE: Larger, more expressive almond-shaped eyes
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.ellipse(centerX - eyeSpacing, eyeY, headWidth * 0.09, headHeight * 0.11, -0.1, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(centerX + eyeSpacing, eyeY, headWidth * 0.09, headHeight * 0.11, 0.1, 0, Math.PI * 2);
                    ctx.fill();

                    // Larger, bright pupils with highlights
                    ctx.fillStyle = '#4A90E2'; // Beautiful blue-ish eyes
                    ctx.beginPath();
                    ctx.arc(centerX - eyeSpacing, eyeY, headWidth * 0.045, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(centerX + eyeSpacing, eyeY, headWidth * 0.045, 0, Math.PI * 2);
                    ctx.fill();

                    // Eye highlights (sparkle)
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(centerX - eyeSpacing - headWidth * 0.02, eyeY - headHeight * 0.03, headWidth * 0.015, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(centerX + eyeSpacing - headWidth * 0.02, eyeY - headHeight * 0.03, headWidth * 0.015, 0, Math.PI * 2);
                    ctx.fill();

                    // Eyelashes (top)
                    ctx.strokeStyle = darkenColor(npc.hairColor, 30);
                    ctx.lineWidth = Math.max(2, screenHeight * 0.012);
                    ctx.lineCap = 'round';
                    for (let i = -1; i <= 1; i++) {
                        ctx.beginPath();
                        ctx.moveTo(centerX - eyeSpacing + i * headWidth * 0.03, eyeY - headHeight * 0.1);
                        ctx.lineTo(centerX - eyeSpacing + i * headWidth * 0.035, eyeY - headHeight * 0.15);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(centerX + eyeSpacing + i * headWidth * 0.03, eyeY - headHeight * 0.1);
                        ctx.lineTo(centerX + eyeSpacing + i * headWidth * 0.035, eyeY - headHeight * 0.15);
                        ctx.stroke();
                    }

                    // Elegant, arched eyebrows
                    ctx.strokeStyle = darkenColor(npc.hairColor, 10);
                    ctx.lineWidth = Math.max(2, screenHeight * 0.01);
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(centerX - eyeSpacing - headWidth * 0.12, eyeY - headHeight * 0.18);
                    ctx.quadraticCurveTo(centerX - eyeSpacing, eyeY - headHeight * 0.22,
                                        centerX - eyeSpacing + headWidth * 0.08, eyeY - headHeight * 0.19);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(centerX + eyeSpacing + headWidth * 0.12, eyeY - headHeight * 0.18);
                    ctx.quadraticCurveTo(centerX + eyeSpacing, eyeY - headHeight * 0.22,
                                        centerX + eyeSpacing - headWidth * 0.08, eyeY - headHeight * 0.19);
                    ctx.stroke();
                } else {
                    // MALE: Strong, confident eyes
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.ellipse(centerX - eyeSpacing, eyeY, headWidth * 0.08, headHeight * 0.09, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(centerX + eyeSpacing, eyeY, headWidth * 0.08, headHeight * 0.09, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Deep, attractive pupils
                    ctx.fillStyle = '#2C3E50'; // Dark, mysterious eyes
                    ctx.beginPath();
                    ctx.arc(centerX - eyeSpacing, eyeY, headWidth * 0.042, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(centerX + eyeSpacing, eyeY, headWidth * 0.042, 0, Math.PI * 2);
                    ctx.fill();

                    // Eye highlights
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.beginPath();
                    ctx.arc(centerX - eyeSpacing - headWidth * 0.018, eyeY - headHeight * 0.025, headWidth * 0.012, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(centerX + eyeSpacing - headWidth * 0.018, eyeY - headHeight * 0.025, headWidth * 0.012, 0, Math.PI * 2);
                    ctx.fill();

                    // Strong, masculine eyebrows
                    ctx.strokeStyle = darkenColor(npc.hairColor, 5);
                    ctx.lineWidth = Math.max(2.5, screenHeight * 0.013);
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(centerX - eyeSpacing - headWidth * 0.11, eyeY - headHeight * 0.16);
                    ctx.lineTo(centerX - eyeSpacing + headWidth * 0.06, eyeY - headHeight * 0.19);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(centerX + eyeSpacing + headWidth * 0.11, eyeY - headHeight * 0.16);
                    ctx.lineTo(centerX + eyeSpacing - headWidth * 0.06, eyeY - headHeight * 0.19);
                    ctx.stroke();
                }
            }

            // Refined nose (smaller, more delicate)
            ctx.fillStyle = darkenColor(npc.skinTone, 8);
            ctx.strokeStyle = darkenColor(npc.skinTone, 15);
            ctx.lineWidth = Math.max(1, screenHeight * 0.004);
            ctx.beginPath();
            ctx.moveTo(centerX, eyeY + headHeight * 0.08);
            ctx.lineTo(centerX - headWidth * 0.025, eyeY + headHeight * 0.2);
            ctx.lineTo(centerX + headWidth * 0.025, eyeY + headHeight * 0.2);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Nostrils (subtle)
            ctx.fillStyle = darkenColor(npc.skinTone, 20);
            ctx.beginPath();
            ctx.ellipse(centerX - headWidth * 0.02, eyeY + headHeight * 0.2, headWidth * 0.008, headHeight * 0.015, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(centerX + headWidth * 0.02, eyeY + headHeight * 0.2, headWidth * 0.008, headHeight * 0.015, 0, 0, Math.PI * 2);
            ctx.fill();

            // Attractive lips
            if (npc.gender === 'female') {
                // FEMALE: Fuller, more defined lips with shine
                ctx.fillStyle = '#D8848F'; // Rose-tinted lips
                ctx.beginPath();
                ctx.ellipse(centerX, eyeY + headHeight * 0.32, headWidth * 0.08, headHeight * 0.03, 0, 0, Math.PI);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(centerX, eyeY + headHeight * 0.32, headWidth * 0.08, headHeight * 0.03, 0, 0, Math.PI, true);
                ctx.fill();

                // Lip shine
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.beginPath();
                ctx.ellipse(centerX, eyeY + headHeight * 0.31, headWidth * 0.04, headHeight * 0.015, 0, 0, Math.PI);
                ctx.fill();

                // Smile
                ctx.strokeStyle = darkenColor(npc.skinTone, 35);
                ctx.lineWidth = Math.max(1.5, screenHeight * 0.006);
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.arc(centerX, eyeY + headHeight * 0.28, headWidth * 0.09, 0.3, Math.PI - 0.3);
                ctx.stroke();
            } else {
                // MALE: Strong, defined lips
                ctx.fillStyle = darkenColor(npc.skinTone, 15);
                ctx.beginPath();
                ctx.moveTo(centerX - headWidth * 0.07, eyeY + headHeight * 0.32);
                ctx.quadraticCurveTo(centerX, eyeY + headHeight * 0.34, centerX + headWidth * 0.07, eyeY + headHeight * 0.32);
                ctx.quadraticCurveTo(centerX, eyeY + headHeight * 0.31, centerX - headWidth * 0.07, eyeY + headHeight * 0.32);
                ctx.fill();

                // Slight smile
                ctx.strokeStyle = darkenColor(npc.skinTone, 35);
                ctx.lineWidth = Math.max(1.5, screenHeight * 0.007);
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.arc(centerX, eyeY + headHeight * 0.3, headWidth * 0.08, 0.25, Math.PI - 0.25);
                ctx.stroke();
            }

            // Blood from mouth for dead NPCs
            if (npc.eyesClosed) {
                const collapseProgress = npc.collapseProgress || 0;
                if (collapseProgress >= 0.3) {
                    ctx.fillStyle = `rgba(139, 0, 0, ${Math.min(0.9, collapseProgress)})`;
                    ctx.beginPath();
                    // Blood dripping from mouth/chin area
                    ctx.ellipse(centerX, eyeY + headHeight * 0.35, headWidth * 0.12, headHeight * 0.08, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Drip pattern
                    ctx.fillRect(centerX - headWidth * 0.02, eyeY + headHeight * 0.4, headWidth * 0.04, headHeight * 0.15);
                }

                // Worm animation disabled for now (was causing errors)
            }

            // Enhanced cheekbone definition and face contouring
            if (npc.gender === 'female') {
                // FEMALE: More pronounced, elegant cheekbones
                ctx.fillStyle = darkenColor(npc.skinTone, 15);
                ctx.globalAlpha = 0.25;
                ctx.beginPath();
                ctx.ellipse(centerX - headWidth * 0.26, eyeY + headHeight * 0.12, headWidth * 0.1, headHeight * 0.07, -0.3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(centerX + headWidth * 0.26, eyeY + headHeight * 0.12, headWidth * 0.1, headHeight * 0.07, 0.3, 0, Math.PI * 2);
                ctx.fill();

                // Highlight on cheekbones for glow
                ctx.fillStyle = lightenColor(npc.skinTone, 25);
                ctx.globalAlpha = 0.2;
                ctx.beginPath();
                ctx.ellipse(centerX - headWidth * 0.24, eyeY + headHeight * 0.08, headWidth * 0.06, headHeight * 0.04, -0.3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(centerX + headWidth * 0.24, eyeY + headHeight * 0.08, headWidth * 0.06, headHeight * 0.04, 0.3, 0, Math.PI * 2);
                ctx.fill();
            } else {
                // MALE: Stronger, more angular cheekbones and jawline
                ctx.fillStyle = darkenColor(npc.skinTone, 18);
                ctx.globalAlpha = 0.3;
                ctx.beginPath();
                ctx.ellipse(centerX - headWidth * 0.28, eyeY + headHeight * 0.18, headWidth * 0.09, headHeight * 0.08, -0.4, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(centerX + headWidth * 0.28, eyeY + headHeight * 0.18, headWidth * 0.09, headHeight * 0.08, 0.4, 0, Math.PI * 2);
                ctx.fill();

                // Strong jawline shadow
                ctx.globalAlpha = 0.2;
                ctx.beginPath();
                ctx.ellipse(centerX - headWidth * 0.18, eyeY + headHeight * 0.42, headWidth * 0.12, headHeight * 0.06, -0.2, 0, Math.PI);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(centerX + headWidth * 0.18, eyeY + headHeight * 0.42, headWidth * 0.12, headHeight * 0.06, 0.2, 0, Math.PI);
                ctx.fill();
            }

            // Chin definition for both genders
            ctx.fillStyle = darkenColor(npc.skinTone, 10);
            ctx.globalAlpha = 0.15;
            ctx.beginPath();
            ctx.ellipse(centerX, eyeY + headHeight * 0.48, headWidth * 0.08, headHeight * 0.05, 0, 0, Math.PI);
            ctx.fill();

            ctx.globalAlpha = 1.0;

            // Name label
            if (npc.possessed || isCurrentHost || npc.everPossessed || npc.isPolice) {
                // Different colors based on state
                if (isCurrentHost) {
                    ctx.fillStyle = '#00FF00'; // Green for currently controlled
                } else if (npc.isPolice && !npc.everPossessed) {
                    ctx.fillStyle = '#FF0000'; // Red for police
                } else if (npc.everPossessed && !npc.currentlyControlled) {
                    ctx.fillStyle = '#FFD700'; // Gold for following
                } else {
                    ctx.fillStyle = '#8a2be2'; // Purple for possessed
                }

                ctx.font = `bold ${Math.max(12, screenHeight * 0.08)}px Arial`;
                ctx.textAlign = 'center';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.strokeText(npc.name, centerX, safeHeadTopPos.y - 10);
                ctx.fillText(npc.name, centerX, safeHeadTopPos.y - 10);

                if (npc.possessed) {
                    ctx.strokeText('‚úì', centerX, safeHeadTopPos.y - 25);
                    ctx.fillText('‚úì', centerX, safeHeadTopPos.y - 25);
                }

                // Show mode for possessed NPCs
                if (npc.everPossessed && !npc.currentlyControlled) {
                    ctx.font = `${Math.max(10, screenHeight * 0.06)}px Arial`;
                    let modeText = '';
                    if (npc.mode === 'stay') {
                        modeText = '‚è∏Ô∏è STAYING';
                        ctx.fillStyle = '#FFD700';
                    } else if (npc.mode === 'follow') {
                        modeText = 'üë£ FOLLOWING';
                        ctx.fillStyle = '#FFD700';
                    } else if (npc.mode === 'attack') {
                        modeText = '‚öîÔ∏è ATTACKING';
                        ctx.fillStyle = '#FF4444';
                    }
                    ctx.strokeText(modeText, centerX, safeHeadTopPos.y + screenHeight * 0.12);
                    ctx.fillText(modeText, centerX, safeHeadTopPos.y + screenHeight * 0.12);
                }

                // Show "üö® POLICE üö®" for police officers
                if (npc.isPolice && !npc.everPossessed) {
                    ctx.font = `${Math.max(10, screenHeight * 0.06)}px Arial`;
                    ctx.fillStyle = '#FF0000';
                    ctx.strokeText('üö® POLICE üö®', centerX, safeHeadTopPos.y + screenHeight * 0.12);
                    ctx.fillText('üö® POLICE üö®', centerX, safeHeadTopPos.y + screenHeight * 0.12);
                }
            }

            // Show "IN LOVE" indicator for NPCs that are in love (visible to all)
            if (npc.inLoveWith && !npc.isDead) {
                const heartY = safeHeadTopPos.y - 25;
                // Draw floating hearts above NPC's head
                ctx.font = `bold ${Math.max(20, screenHeight * 0.12)}px Arial`;
                ctx.textAlign = 'center';

                // Animated bouncing hearts
                const heartBounce = Math.sin(Date.now() / 300) * 5;
                const heartFloat = Math.sin(Date.now() / 500) * 3;

                // Special visual for Cupid-loved NPCs (pink glow + arrow icon)
                if (npc.cupidLove) {
                    // Pink glowing aura
                    ctx.shadowColor = '#FF1493';
                    ctx.shadowBlur = 20;
                    ctx.fillStyle = '#FF69B4'; // Brighter pink
                    ctx.strokeStyle = '#FFB6C1'; // Light pink outline
                } else {
                    // Normal love hearts
                    ctx.fillStyle = '#FF1493'; // Deep pink
                    ctx.strokeStyle = '#FF69B4'; // Hot pink outline
                }
                ctx.lineWidth = 2;

                // Center heart (or bow & arrow for Cupid love)
                if (npc.cupidLove) {
                    ctx.strokeText('üíò', centerX, heartY + heartBounce); // Cupid arrow emoji
                    ctx.fillText('üíò', centerX, heartY + heartBounce);
                } else {
                    ctx.strokeText('üíï', centerX, heartY + heartBounce);
                    ctx.fillText('üíï', centerX, heartY + heartBounce);
                }

                // Side hearts (smaller)
                ctx.font = `bold ${Math.max(15, screenHeight * 0.09)}px Arial`;
                ctx.strokeText('üíñ', centerX - screenWidth * 0.6, heartY + heartFloat);
                ctx.fillText('üíñ', centerX - screenWidth * 0.6, heartY + heartFloat);
                ctx.strokeText('üíñ', centerX + screenWidth * 0.6, heartY + heartFloat);
                ctx.fillText('üíñ', centerX + screenWidth * 0.6, heartY + heartFloat);

                ctx.shadowBlur = 0; // Reset shadow
                ctx.textAlign = 'left';
            }

            // Continue with health bar and other elements
            if (npc.possessed || isCurrentHost || npc.everPossessed || npc.isPolice) {
                // Health bar
                if (npc.health < npc.maxHealth || npc.isPolice) {
                    const barWidth = screenWidth * 0.8;
                    const barHeight = screenHeight * 0.03;
                    const barY = safeHeadTopPos.y - screenHeight * 0.08;

                    // Background
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.fillRect(centerX - barWidth / 2, barY, barWidth, barHeight);

                    // Health
                    const healthPercent = npc.health / npc.maxHealth;
                    ctx.fillStyle = healthPercent > 0.5 ? '#00FF00' : healthPercent > 0.25 ? '#FFFF00' : '#FF0000';
                    ctx.fillRect(centerX - barWidth / 2, barY, barWidth * healthPercent, barHeight);

                    // Border
                    ctx.strokeStyle = '#FFF';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(centerX - barWidth / 2, barY, barWidth, barHeight);
                }

                ctx.textAlign = 'left';
            }

            // Restore canvas for dead bodies (rotated rendering)
            if (npc.isDead) {
                ctx.restore();
            }
        }

        function drawPerson(npc, isHost = false) {
            ctx.save();

            const x = npc.x;
            const y = npc.y;
            const scale = npc.height / 30;

            // Body type modifiers
            let bodyWidth = 16;
            let headSize = 9;
            let shoulderWidth = 18;
            if (npc.bodyType === 'slim') {
                bodyWidth = 13;
                headSize = 8;
                shoulderWidth = 15;
            } else if (npc.bodyType === 'heavy') {
                bodyWidth = 22;
                headSize = 10;
                shoulderWidth = 24;
            } else if (npc.bodyType === 'athletic') {
                bodyWidth = 18;
                headSize = 9;
                shoulderWidth = 22;
            }

            // Feet/shoes
            ctx.fillStyle = '#1A1A1A';
            ctx.beginPath();
            ctx.ellipse(x - bodyWidth * 0.25, y + 22 * scale, 4, 2.5, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(x + bodyWidth * 0.25, y + 22 * scale, 4, 2.5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Legs with proper shading
            const legColor = npc.color === '#4A90E2' ? '#2C3E50' : darkenColor(npc.color, 40);
            ctx.fillStyle = legColor;

            // Left leg (with volume)
            ctx.beginPath();
            ctx.moveTo(x - bodyWidth * 0.15, y + 5 * scale);
            ctx.lineTo(x - bodyWidth * 0.2, y + 5 * scale);
            ctx.lineTo(x - bodyWidth * 0.28, y + 22 * scale);
            ctx.lineTo(x - bodyWidth * 0.22, y + 22 * scale);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Right leg
            ctx.beginPath();
            ctx.moveTo(x + bodyWidth * 0.15, y + 5 * scale);
            ctx.lineTo(x + bodyWidth * 0.2, y + 5 * scale);
            ctx.lineTo(x + bodyWidth * 0.28, y + 22 * scale);
            ctx.lineTo(x + bodyWidth * 0.22, y + 22 * scale);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Torso/body with realistic shape
            ctx.fillStyle = npc.color;
            if (npc.gender === 'female' && npc.bodyType !== 'heavy') {
                // Female body shape - curves
                ctx.beginPath();
                ctx.moveTo(x - shoulderWidth * 0.45, y - 12 * scale);
                ctx.lineTo(x + shoulderWidth * 0.45, y - 12 * scale);
                ctx.lineTo(x + bodyWidth * 0.4, y - 2 * scale);
                ctx.lineTo(x + bodyWidth * 0.35, y + 5 * scale);
                ctx.lineTo(x - bodyWidth * 0.35, y + 5 * scale);
                ctx.lineTo(x - bodyWidth * 0.4, y - 2 * scale);
                ctx.closePath();
                ctx.fill();

                // Shading
                const gradient = ctx.createLinearGradient(x - bodyWidth * 0.5, y, x + bodyWidth * 0.5, y);
                gradient.addColorStop(0, darkenColor(npc.color, 20));
                gradient.addColorStop(0.5, npc.color);
                gradient.addColorStop(1, darkenColor(npc.color, 20));
                ctx.fillStyle = gradient;
                ctx.fill();
            } else {
                // Male body shape - straighter
                ctx.beginPath();
                ctx.moveTo(x - shoulderWidth * 0.5, y - 12 * scale);
                ctx.lineTo(x + shoulderWidth * 0.5, y - 12 * scale);
                ctx.lineTo(x + bodyWidth * 0.45, y + 5 * scale);
                ctx.lineTo(x - bodyWidth * 0.45, y + 5 * scale);
                ctx.closePath();
                ctx.fill();

                // Shading
                const gradient = ctx.createLinearGradient(x - bodyWidth * 0.5, y, x + bodyWidth * 0.5, y);
                gradient.addColorStop(0, darkenColor(npc.color, 20));
                gradient.addColorStop(0.5, npc.color);
                gradient.addColorStop(1, darkenColor(npc.color, 20));
                ctx.fillStyle = gradient;
                ctx.fill();
            }

            // Body outline
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1.5;
            ctx.stroke();

            // Upper arms (sleeves)
            ctx.fillStyle = npc.color;
            ctx.beginPath();
            ctx.ellipse(x - shoulderWidth * 0.5, y - 8 * scale, 3.5, 8, Math.PI * 0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.stroke();

            ctx.beginPath();
            ctx.ellipse(x + shoulderWidth * 0.5, y - 8 * scale, 3.5, 8, -Math.PI * 0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Forearms (skin)
            ctx.strokeStyle = npc.skinTone;
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';

            // Left forearm
            ctx.beginPath();
            ctx.moveTo(x - shoulderWidth * 0.5, y - 2 * scale);
            ctx.lineTo(x - shoulderWidth * 0.6, y + 5 * scale);
            ctx.stroke();

            // Right forearm
            ctx.beginPath();
            ctx.moveTo(x + shoulderWidth * 0.5, y - 2 * scale);
            ctx.lineTo(x + shoulderWidth * 0.6, y + 5 * scale);
            ctx.stroke();

            // Hands with fingers
            ctx.fillStyle = npc.skinTone;
            // Left hand
            ctx.beginPath();
            ctx.ellipse(x - shoulderWidth * 0.6, y + 5 * scale, 3, 4, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = darkenColor(npc.skinTone, 30);
            ctx.lineWidth = 0.5;
            ctx.stroke();

            // Right hand
            ctx.beginPath();
            ctx.ellipse(x + shoulderWidth * 0.6, y + 5 * scale, 3, 4, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = darkenColor(npc.skinTone, 30);
            ctx.lineWidth = 0.5;
            ctx.stroke();

            // Neck with shading
            ctx.fillStyle = npc.skinTone;
            ctx.beginPath();
            ctx.moveTo(x - 4, y - 13 * scale);
            ctx.lineTo(x + 4, y - 13 * scale);
            ctx.lineTo(x + 3, y - 18 * scale);
            ctx.lineTo(x - 3, y - 18 * scale);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = darkenColor(npc.skinTone, 20);
            ctx.lineWidth = 1;
            ctx.stroke();

            // Head (oval shaped, more realistic)
            const headGradient = ctx.createRadialGradient(x - 2, y - 22 * scale, 2, x, y - 20 * scale, headSize);
            headGradient.addColorStop(0, lightenColor(npc.skinTone, 20));
            headGradient.addColorStop(1, npc.skinTone);
            ctx.fillStyle = headGradient;
            ctx.beginPath();
            ctx.ellipse(x, y - 20 * scale, headSize * 0.85, headSize, 0, 0, Math.PI * 2);
            ctx.fill();

            // Head outline
            ctx.strokeStyle = darkenColor(npc.skinTone, 40);
            ctx.lineWidth = 1;
            ctx.stroke();

            // Ears
            ctx.fillStyle = npc.skinTone;
            ctx.beginPath();
            ctx.ellipse(x - headSize * 0.8, y - 20 * scale, 2, 3, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(x + headSize * 0.8, y - 20 * scale, 2, 3, 0, 0, Math.PI * 2);
            ctx.fill();

            // Hair based on style
            ctx.fillStyle = npc.hairColor;
            if (npc.hairStyle === 'short') {
                ctx.beginPath();
                ctx.ellipse(x, y - 24 * scale, headSize * 0.9, headSize * 0.6, 0, Math.PI, 0);
                ctx.fill();
                ctx.strokeStyle = darkenColor(npc.hairColor, 30);
                ctx.lineWidth = 1;
                ctx.stroke();
            } else if (npc.hairStyle === 'long') {
                // Top hair
                ctx.beginPath();
                ctx.ellipse(x, y - 24 * scale, headSize * 0.9, headSize * 0.6, 0, Math.PI, 0);
                ctx.fill();
                // Long flowing hair
                ctx.beginPath();
                ctx.moveTo(x - headSize * 0.85, y - 20 * scale);
                ctx.bezierCurveTo(x - headSize * 1.1, y - 15 * scale, x - headSize * 1.2, y - 8 * scale, x - headSize * 0.7, y - 5 * scale);
                ctx.lineTo(x + headSize * 0.7, y - 5 * scale);
                ctx.bezierCurveTo(x + headSize * 1.2, y - 8 * scale, x + headSize * 1.1, y - 15 * scale, x + headSize * 0.85, y - 20 * scale);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = darkenColor(npc.hairColor, 30);
                ctx.lineWidth = 1;
                ctx.stroke();
            } else if (npc.hairStyle === 'ponytail') {
                ctx.beginPath();
                ctx.ellipse(x, y - 24 * scale, headSize * 0.9, headSize * 0.6, 0, Math.PI, 0);
                ctx.fill();
                // Ponytail
                ctx.beginPath();
                ctx.ellipse(x - headSize * 0.9, y - 18 * scale, 4, 8, Math.PI * 0.3, 0, Math.PI * 2);
                ctx.fill();
            } else if (npc.hairStyle === 'bald') {
                // Just shine on scalp
                ctx.fillStyle = lightenColor(npc.skinTone, 30);
                ctx.beginPath();
                ctx.arc(x - 2, y - 24 * scale, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Facial features
            const eyeY = y - 20 * scale;

            if (npc.possessed) {
                // Purple glowing eyes when possessed
                ctx.fillStyle = '#8a2be2';
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#8a2be2';
                ctx.beginPath();
                ctx.ellipse(x - headSize * 0.35, eyeY, 3, 3.5, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(x + headSize * 0.35, eyeY, 3, 3.5, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            } else {
                // Eye whites
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.ellipse(x - headSize * 0.35, eyeY, 2.5, 3, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(x + headSize * 0.35, eyeY, 2.5, 3, 0, 0, Math.PI * 2);
                ctx.fill();

                // Pupils
                ctx.fillStyle = '#2C3E50';
                ctx.beginPath();
                ctx.arc(x - headSize * 0.35, eyeY, 1.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(x + headSize * 0.35, eyeY, 1.5, 0, Math.PI * 2);
                ctx.fill();

                // Eye outlines
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 0.8;
                ctx.beginPath();
                ctx.ellipse(x - headSize * 0.35, eyeY, 2.5, 3, 0, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.ellipse(x + headSize * 0.35, eyeY, 2.5, 3, 0, 0, Math.PI * 2);
                ctx.stroke();

                // Eyebrows
                ctx.strokeStyle = darkenColor(npc.hairColor, 20);
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(x - headSize * 0.5, eyeY - 4);
                ctx.lineTo(x - headSize * 0.2, eyeY - 5);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(x + headSize * 0.5, eyeY - 4);
                ctx.lineTo(x + headSize * 0.2, eyeY - 5);
                ctx.stroke();
            }

            // Nose with shading
            ctx.fillStyle = darkenColor(npc.skinTone, 10);
            ctx.beginPath();
            ctx.moveTo(x, eyeY + 3);
            ctx.lineTo(x - 2, eyeY + 7);
            ctx.lineTo(x + 2, eyeY + 7);
            ctx.closePath();
            ctx.fill();

            // Nostrils
            ctx.fillStyle = darkenColor(npc.skinTone, 40);
            ctx.beginPath();
            ctx.ellipse(x - 1.5, eyeY + 7, 0.8, 1, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(x + 1.5, eyeY + 7, 0.8, 1, 0, 0, Math.PI * 2);
            ctx.fill();

            // Mouth
            ctx.strokeStyle = darkenColor(npc.skinTone, 50);
            ctx.lineWidth = 1.5;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.arc(x, eyeY + 11, 3, 0.2, Math.PI - 0.2);
            ctx.stroke();

            // Lips
            ctx.strokeStyle = '#B8696C';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(x, eyeY + 11, 3, 0.2, Math.PI - 0.2);
            ctx.stroke();

            // Possessed checkmark
            if (npc.possessed) {
                ctx.fillStyle = '#8a2be2';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#8a2be2';
                ctx.fillText('‚úì', x, y - (26 + headSize) * scale);
                ctx.shadowBlur = 0;
            }

            // Host glow
            if (isHost) {
                ctx.strokeStyle = '#da70d6';
                ctx.lineWidth = 4;
                ctx.shadowBlur = 25;
                ctx.shadowColor = '#8a2be2';
                ctx.beginPath();
                ctx.arc(x, y, 35, 0, Math.PI * 2);
                ctx.stroke();
                ctx.shadowBlur = 0;
            }

            ctx.restore();
        }

        function darkenColor(color, amount) {
            const num = parseInt(color.replace('#', ''), 16);
            const r = Math.max(0, (num >> 16) - amount);
            const g = Math.max(0, ((num >> 8) & 0x00FF) - amount);
            const b = Math.max(0, (num & 0x0000FF) - amount);
            return '#' + ((r << 16) | (g << 8) | b).toString(16).padStart(6, '0');
        }

        function lightenColor(color, amount) {
            const num = parseInt(color.replace('#', ''), 16);
            const r = Math.min(255, (num >> 16) + amount);
            const g = Math.min(255, ((num >> 8) & 0x00FF) + amount);
            const b = Math.min(255, (num & 0x0000FF) + amount);
            return '#' + ((r << 16) | (g << 8) | b).toString(16).padStart(6, '0');
        }

        function shadowDeath() {
            console.log('Shadow has been defeated! Restarting game...');

            // Release current possession
            if (currentHost) {
                currentHost.currentlyControlled = false;
                currentHost = null;
            }
            isPossessing = false;

            // Reset all NPCs to normal state
            npcs.forEach(npc => {
                npc.possessed = false;
                npc.everPossessed = false;
                npc.currentlyControlled = false;
                npc.mode = undefined; // Will reset to default AI behavior
                npc.targetX = null;
                npc.targetZ = null;
                npc.possessionAnim = 0;
                npc.backArch = 0;
                npc.stripAnim = 0;
                npc.leftArmAngle = 0;
                npc.rightArmAngle = 0;
                npc.clothingLevel = 3; // Re-clothe all NPCs
                npc.health = npc.maxHealth; // Restore health
                npc.activeEffects = []; // Clear effects
            });

            // Wait 2 seconds then restart
            setTimeout(() => {
                restartGame();
            }, 2000);
        }

        function gameOver() {
            gameRunning = false;
            document.getElementById('finalPossessed').textContent = possessedCount;
            document.getElementById('finalTime').textContent = gameTime;
            document.getElementById('gameOver').classList.add('show');
        }

        function restartGame() {
            gameRunning = true;
            shadowEnergy = 100;
            possessedCount = 0;
            gameTime = 0;
            gameStartTime = Date.now();
            isPossessing = false;
            currentHost = null;
            policeSpawned = false; // Reset police spawn flag
            shadow.x = worldWidth / 2;
            shadow.y = 100;
            shadow.z = worldDepth / 2;
            shadow.angle = 0;
            shadow.pitch = 0;
            shadow.trail = [];
            shadow.particles = [];
            shadow.health = shadow.maxHealth; // Reset shadow health
            shadow.invulnerable = false;
            shadow.invulnerabilityTime = 0;
            npcs.length = 0;
            buildings.length = 0;

            // Reset all key states to prevent infinite movement
            for (let key in keys) {
                keys[key] = false;
            }

            document.getElementById('gameOver').classList.remove('show');
            document.getElementById('possessionPrompt').classList.remove('show');
            init();

            // Auto-possess a random NPC when starting/restarting game
            if (npcs.length > 0) {
                const randomNPC = npcs[Math.floor(Math.random() * npcs.length)];
                shadow.x = randomNPC.x;
                shadow.z = randomNPC.z;
                possessNPC(randomNPC);
                console.log('üéØ Auto-possessed random NPC:', randomNPC.name);
            }
        }

        // Game loop
        let lastTime = 0;
        function gameLoop(currentTime) {
            const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1);
            lastTime = currentTime;

            try {
                update(deltaTime);
                draw();
            } catch (error) {
                console.error('Game loop error:', error);
                console.error('Error stack:', error.stack);
                // Continue running despite errors
            }

            requestAnimationFrame(gameLoop);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // Start game
        init();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
